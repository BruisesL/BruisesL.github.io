<!DOCTYPE html>













<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>集合框架 - BruisesL&#39;s blog</title>

  
  
  <meta name="description" content="集合框架 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
集合框架被设计成要满足以下几个目标：
该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList**, **HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合Collection，存储一个元素集合，另一种是图Map，存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。
接口 接口名称 接口描述 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和Set)。Collection 接口存储一组不唯一，无序的对象。Collection接口才可以使用foreach循环。 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 Set 接口 Set 接口具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 SortedSet 接口 继承于Set保存有序的集合。 Map接口 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 Map." />
  <meta name="author" content="BruisesL" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://bruisesl.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/github.svg" />
  

  
  <link rel="icon" href="https://bruisesl.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://bruisesl.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.110.0">

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="集合框架" />
<meta property="og:description" content="集合框架 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
集合框架被设计成要满足以下几个目标：
该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList**, **HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合Collection，存储一个元素集合，另一种是图Map，存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。
接口 接口名称 接口描述 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和Set)。Collection 接口存储一组不唯一，无序的对象。Collection接口才可以使用foreach循环。 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 Set 接口 Set 接口具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 SortedSet 接口 继承于Set保存有序的集合。 Map接口 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 Map." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-02-18T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-18T00:00:00+00:00" />

  
  <meta itemprop="name" content="集合框架">
<meta itemprop="description" content="集合框架 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
集合框架被设计成要满足以下几个目标：
该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList**, **HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合Collection，存储一个元素集合，另一种是图Map，存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。
接口 接口名称 接口描述 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和Set)。Collection 接口存储一组不唯一，无序的对象。Collection接口才可以使用foreach循环。 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 Set 接口 Set 接口具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 SortedSet 接口 继承于Set保存有序的集合。 Map接口 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 Map."><meta itemprop="datePublished" content="2023-02-18T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-02-18T00:00:00+00:00" />
<meta itemprop="wordCount" content="1080">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="集合框架"/>
<meta name="twitter:description" content="集合框架 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
集合框架被设计成要满足以下几个目标：
该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList**, **HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合Collection，存储一个元素集合，另一种是图Map，存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。
接口 接口名称 接口描述 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和Set)。Collection 接口存储一组不唯一，无序的对象。Collection接口才可以使用foreach循环。 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 Set 接口 Set 接口具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 SortedSet 接口 继承于Set保存有序的集合。 Map接口 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 Map."/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://bruisesl.github.io">BruisesL&#39;s blog</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/about/">About</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/BruisesL"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <aside>
      <time>February 18, 2023</time>
      
      <span>BruisesL</span>
      
    </aside>
    <h1>集合框架</h1>
  </header>
  <section class="post-content"><h2 id="集合框架">集合框架</h2>
<p>早在 Java 2 中之前，Java 就提供了特设类。比如：<code>Dictionary</code>, <code>Vector</code>, <code>Stack</code>, 和 <code>Properties</code> 这些类用来存储和操作对象组。</p>
<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 <code>Vector</code> 类的方式和使用 <code>Properties</code> 类的方式有着很大不同。</p>
<p>集合框架被设计成要满足以下几个<strong>目标</strong>：</p>
<ul>
<li>该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： <code>LinkedList</code>**, **<code>HashSet</code>, 和 <code>TreeSet</code> 等,除此之外你也可以通过这些接口实现自己的集合。</p>
<p><img src="/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Java集合框架图"></p>
<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合<code>Collection</code>，存储一个元素集合，另一种是图<code>Map</code>，存储键/值对映射。<code>Collection</code> 接口又有 3 种子类型，<code>List</code>、<code>Set</code> 和 <code>Queue</code>，再下面是一些抽象类，最后是具体实现类，常用的有<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>HashMap</code>、<code>LinkedHashMap</code> 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<ul>
<li><strong>接口</strong>：是代表集合的抽象数据类型。例如 <code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code> 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li>
<li><strong>实现（类）</strong>：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：<code>ArrayList</code>、<code>LinkedList</code>、<code>HashSet</code>、<code>HashMap</code>。</li>
<li><strong>算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li>
</ul>
<p>除了集合，该框架也定义了几个 <code>Map</code> 接口和类。<code>Map</code> 里存储的是键/值对。尽管 <code>Map</code> 不是集合，但是它们完全整合在集合中。</p>
<p><img src="/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB.png" alt="集合框架体系"></p>
<h3 id="接口">接口</h3>
<table>
<thead>
<tr>
<th style="text-align:left">接口名称</th>
<th style="text-align:left">接口描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Collection</code> 接口</td>
<td style="text-align:left"><code>Collection</code> 是最基本的集合接口，一个 <code>Collection</code> 代表一组 <code>Object</code>，即 <code>Collection</code> 的元素, Java不提供直接继承自<code>Collection</code>的类，只提供继承于的子接口(如<code>List</code>和<code>Set</code>)。<code>Collection</code> 接口存储一组<strong>不唯一</strong>，<strong>无序</strong>的对象。<code>Collection</code>接口才可以使用<code>foreach</code>循环。</td>
</tr>
<tr>
<td style="text-align:left"><code>List</code> 接口</td>
<td style="text-align:left"><code>List</code>接口是一个有序的 <code>Collection</code>，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组<strong>不唯一</strong>，<strong>有序</strong>（插入顺序）的对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>Set</code> 接口</td>
<td style="text-align:left"><code>Set</code> 接口具有与 <code>Collection</code> 完全一样的接口，只是行为上不同，<code>Set</code> 不保存重复的元素。<code>Set</code> 接口存储一组<strong>唯一</strong>，<strong>无序</strong>的对象。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedSet</code> 接口</td>
<td style="text-align:left">继承于<code>Set</code>保存有序的集合。</td>
</tr>
<tr>
<td style="text-align:left"><code>Map</code>接口</td>
<td style="text-align:left"><code>Map</code> 接口存储一组键值对象，提供key（键）到value（值）的映射。</td>
</tr>
<tr>
<td style="text-align:left"><code>Map.Entry</code></td>
<td style="text-align:left"><code>Map.Entry</code> 描述在一个Map中的一个元素（键/值对）。是一个 <strong><code>Map</code> 的内部接口</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><code>SortedMap</code> 接口</td>
<td style="text-align:left"><code>SortedMap</code> 接口继承于 Map，使 Key 保持在升序排列。</td>
</tr>
<tr>
<td style="text-align:left"><del><code>Enumeration</code>  接口</del></td>
<td style="text-align:left"><del><code>Enumeration</code>  接口是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</del></td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>Set</code>和<code>List</code>的区别</p>
<ol>
<li>
<p><code>Set</code> 接口实例存储的是<strong>无序</strong>的，<strong>不重复</strong>的数据。<code>List</code> 接口实例存储的是<strong>有序</strong>的，<strong>可重复</strong>的元素。</p>
</li>
<li>
<p><code>Set</code> <strong>检索效率低</strong>，<strong>删除和插入效率高</strong>，插入和删除<strong>不会引起元素位置改变</strong> （实现类有<code>HashSet</code>、<code>TreeSet</code>）。</p>
</li>
<li>
<p><code>List</code> 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 <code>List</code> 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变。 （实现类有<code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>）</p>
</li>
</ol>
</li>
</ul>
<h3 id="集合实现类集合类">集合实现类（集合类）</h3>
<table>
<thead>
<tr>
<th style="text-align:left">类名称</th>
<th style="text-align:left">类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AbstractCollection</code></td>
<td style="text-align:left"><code>AbstractCollection</code>  实现了大部分的集合接口。</td>
</tr>
<tr>
<td style="text-align:left"><code>AbstractList</code></td>
<td style="text-align:left"><code>AbstractList</code>  继承于<code>AbstractCollection</code> 并且实现了大部分List接口。</td>
</tr>
<tr>
<td style="text-align:left"><code>AbstractSequentialList</code></td>
<td style="text-align:left"><code>AbstractSequentialList</code>  继承于 <code>AbstractList</code> ，提供了对数据元素的链式访问而不是随机访问。</td>
</tr>
<tr>
<td style="text-align:left"><code>LinkedList</code></td>
<td style="text-align:left"><code>LinkedList</code> 该类实现了<code>List</code>接口，允许有<code>null</code>元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个<code>List</code>，则必须自己实现访问同步，解决方法就是在创建<code>List</code>时候构造一个同步的<code>List</code>。例如：<code>List list=Collections.synchronizedList(newLinkedList(...));``LinkedList</code> 查找效率低。</td>
</tr>
<tr>
<td style="text-align:left"><code>ArrayList</code></td>
<td style="text-align:left"><code>ArrayList</code> 该类也是实现了<code>List</code>的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。<code>ArrayList</code> 增长当前长度的50%，插入删除效率低。</td>
</tr>
<tr>
<td style="text-align:left"><code>AbstractSet</code></td>
<td style="text-align:left"><code>AbstractSet</code>  继承于<code>AbstractCollection</code> 并且实现了大部分<code>Set</code>接口。</td>
</tr>
<tr>
<td style="text-align:left"><code>HashSet</code></td>
<td style="text-align:left"><code>HashSet</code> 该类实现了<code>Set</code>接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为<code>null</code>的元素，但最多只能一个。</td>
</tr>
<tr>
<td style="text-align:left"><code>LinkedHashSet</code></td>
<td style="text-align:left"><code>LinkedHashSet</code> 具有可预知迭代顺序的 <code>Set</code> 接口的哈希表和链接列表实现。</td>
</tr>
<tr>
<td style="text-align:left"><code>TreeSet</code></td>
<td style="text-align:left"><code>TreeSet</code> 该类实现了<code>Set</code>接口，可以实现排序等功能。</td>
</tr>
<tr>
<td style="text-align:left"><code>AbstractMap</code></td>
<td style="text-align:left"><code>AbstractMap</code>  实现了大部分的Map接口。</td>
</tr>
<tr>
<td style="text-align:left"><code>HashMap</code></td>
<td style="text-align:left"><code>HashMap</code> 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了<code>Map</code>接口，根据键的<code>HashCode</code>值存储数据，具有很快的访问速度，最多允许一条记录的键为<code>null</code>，不支持线程同步。</td>
</tr>
<tr>
<td style="text-align:left"><code>TreeMap</code></td>
<td style="text-align:left"><code>TreeMap</code> 继承了<code>AbstractMap</code>，并且使用一颗树。</td>
</tr>
<tr>
<td style="text-align:left"><code>WeakHashMap</code></td>
<td style="text-align:left"><code>WeakHashMap</code> 继承<code>AbstractMap</code>类，使用弱密钥的哈希表。</td>
</tr>
<tr>
<td style="text-align:left"><code>LinkedHashMap</code></td>
<td style="text-align:left"><code>LinkedHashMap</code> 继承于<code>HashMap</code>，使用元素的自然顺序对元素进行排序.</td>
</tr>
<tr>
<td style="text-align:left"><code>IdentityHashMap</code></td>
<td style="text-align:left"><code>IdentityHashMap</code> 继承<code>AbstractMap</code>类，比较文档时使用引用相等。</td>
</tr>
<tr>
<td style="text-align:left"><code>Vector</code></td>
<td style="text-align:left"><code>Vector</code> 该类和<code>ArrayList</code>非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</td>
</tr>
<tr>
<td style="text-align:left"><code>Stack</code></td>
<td style="text-align:left"><code>Stack</code> 栈是<code>Vector</code>的一个子类，它实现了一个标准的后进先出的栈。</td>
</tr>
<tr>
<td style="text-align:left"><code>Dictionary</code></td>
<td style="text-align:left"><code>Dictionary</code> 类是一个抽象类，用来存储键/值对，作用和Map类相似。</td>
</tr>
<tr>
<td style="text-align:left"><code>Hashtable</code></td>
<td style="text-align:left"><code>Hashtable</code> 是 <code>Dictionary</code> 类的子类，位于 <code>java.util</code> 包中。</td>
</tr>
<tr>
<td style="text-align:left"><code>Properties</code></td>
<td style="text-align:left"><code>Properties</code> 继承于 <code>Hashtable</code>，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</td>
</tr>
<tr>
<td style="text-align:left"><code>BitSet</code></td>
<td style="text-align:left"><code>BitSet</code> 一个<code>Bitset</code>类创建一种特殊类型的数组来保存位值。<code>BitSet</code>中数组大小会随需要增加。</td>
</tr>
</tbody>
</table>
<h3 id="迭代器">迭代器</h3>
<p>迭代器，可以通过循环来得到或删除集合的元素。</p>
<p><code>Iterable</code>是一个定义集合遍历方式的接口，有方法 <code>iterator()  </code>获取迭代器对象，因此实现了<code>Iterable</code>接口的类才可以使用<code>for-each</code>循环遍历，例如实现了<code>Collection</code>接口的类。</p>
<p><code>Iterator</code> 是一个定义了集合迭代器的借口，有方法 <code>hasNext()</code>、<code>next()</code>、<code>remove()</code> 来使用迭代器对集合进行遍历操作。</p>
<p><code>ListIterator</code> 继承了 <code>Iterator</code>，以允许双向遍历列表和修改元素，<code>List</code>接口可以使用双向迭代器。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>     List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;();</span>
</span></span><span style="display:flex;"><span>     list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Hello&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;World&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;HAHAHAHA&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 第一种遍历方法使用 For-Each 遍历 List
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String str <span style="color:#f92672">:</span> list<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 第二种遍历，把链表变为数组相关的内容进行遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     String<span style="color:#f92672">[]</span> strArray <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()];</span>
</span></span><span style="display:flex;"><span>     list<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span>strArray<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> strArray<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#75715e">// 可以改写为  for(String str:strArray) 这种形式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>strArray<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>     <span style="color:#75715e">// 第三种遍历 使用迭代器进行相关遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     
</span></span><span style="display:flex;"><span>     Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> ite<span style="color:#f92672">=</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>ite<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#75715e">// 判断下一个元素之后有值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>         System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>ite<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h3 id="比较器">比较器</h3>
<p><code>TreeSet</code> 和 <code>TreeMap</code>的按照排序顺序来存储元素。这是通过实现了比较器接口 <code>Comparator</code> 来精确定义按照什么样的排序顺序，这个接口可以以不同的方式来排序一个集合。</p>
<p><code>Comparable </code> 是自然排序使用的接口，提供的方法<code>compareTo(T o)</code>实现，当一个类实现了<code>Comparable</code>接口，就意味着该类支持排序。</p>
<p><code>Comparator</code> 是比较器接口，可以实现此接口自定义排序规则，用自定义的比较器入参，可以完成集合的自定义排序，例如 <code>compare(E a, E b)</code> 返回值为 <code>int</code> 类型。</p>
<p><strong>注</strong>：当自然排序与自定义比较器同时使用，自定义比较器优先级更高。</p>
<p><strong><code>Comparable</code> 与 <code>Comparator</code>比较</strong>：</p>
<p>用 <code>Comparable</code> 简单， 只要实现 <code>Comparable</code> 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码；</p>
<p>用 <code>Comparator</code> 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去即可进行比较。</p>
<p><strong>判断重复的标准</strong>：</p>
<p>调用对象的<code>compareTo</code>方法进行升序排列（<code>A.compareTo(B)</code>），如果<code>return 0</code> 表示相等；返回值大于0，则认为A大于B；如果返回值小于0，则认为A小于B。</p>
<h3 id="collections工具类">Collections工具类</h3>
<p>用于操作<code>Collection</code>下的集合。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>addAll(Collection c, Object... elements)</code></td>
<td>将所有指定的元素elements添加到指定的集合c中。</td>
</tr>
<tr>
<td><code>fill(List list, Object obj)</code></td>
<td>用指定的元素obj代替指定集合list中的所有元素。(批量初始化)</td>
</tr>
<tr>
<td><code>max(Collection coll)</code></td>
<td>根据自然顺序返回给定集合coll的最大元素。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>max(Collection coll, Comparator comp)</code></td>
<td>据比较器排序comp，返回给定集合coll中的最大元素。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>min(Collection coll)</code></td>
<td>根据自然顺序返回给定集合coll的最小元素。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>min(Collection coll, Comparator comp)</code></td>
<td>据比较器排序comp，返回给定集合coll中的最小元素。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>reverse(List list)</code></td>
<td>反转指定集合list中元素的顺序。</td>
</tr>
<tr>
<td><code>shuffle(List list)</code></td>
<td>将集合中list中元素的随机打乱顺序，常常用来洗牌。</td>
</tr>
<tr>
<td><code>sort(List list)</code></td>
<td>将list集合升序排序。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>sort(List list, Comparator c)</code></td>
<td>根据指定的比较器c对指定的集合list进行排序。（注意：元素必须是同一种类型）</td>
</tr>
<tr>
<td><code>swap(List list, int i, int j)</code></td>
<td>交换集合list中下标i和下标j的元素位置。</td>
</tr>
<tr>
<td><code>synchronizedList(List list)</code></td>
<td>将list对象转换为线程安全的。</td>
</tr>
<tr>
<td><code>synchronizedMap(Map&lt;K,V&gt; m)</code></td>
<td>将map对象转换为线程安全的。</td>
</tr>
<tr>
<td><code>synchronizedSet(Set s)</code></td>
<td>将set对象转换为线程安全的。</td>
</tr>
</tbody>
</table>
<h2 id="arraylist">ArrayList</h2>
<p><code>ArrayList</code> 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<code>ArrayList</code> 继承了 <code>AbstractList</code> ，并实现了 <code>List</code> 接口。</p>
<p>扩容底层是使用<code>Arrays.copyOf</code>，在元素个数大于数组长度的时候进行扩容，扩容每次扩大到原长度的1.5倍，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 导包 与 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> java.util.ArrayList<span style="color:#f92672">;</span> <span style="color:#75715e">// 引入 ArrayList 类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// objectName: 对象名。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ArrayList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> objectName <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span> <span style="color:#75715e">// 初始化
</span></span></span></code></pre></div><p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add()</code></td>
<td>将元素插入到指定位置的 arraylist 中</td>
</tr>
<tr>
<td><code>addAll()</code></td>
<td>添加集合中的所有元素到 arraylist 中</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>删除 arraylist 中的所有元素</td>
</tr>
<tr>
<td><code>clone()</code></td>
<td>复制一份 arraylist</td>
</tr>
<tr>
<td><code>contains()</code></td>
<td>判断元素是否在 arraylist</td>
</tr>
<tr>
<td><code>get()</code></td>
<td>通过索引值获取 arraylist 中的元素</td>
</tr>
<tr>
<td><code>indexOf()</code></td>
<td>返回 arraylist 中元素的索引值</td>
</tr>
<tr>
<td><code>removeAll()</code></td>
<td>删除存在于指定集合中的 arraylist 里的所有元素</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>删除 arraylist 里的单个元素</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回 arraylist 里元素数量</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>判断 arraylist 是否为空</td>
</tr>
<tr>
<td><code>subList()</code></td>
<td>截取部分 arraylist 的元素</td>
</tr>
<tr>
<td><code>set()</code></td>
<td>替换 arraylist 中指定索引的元素</td>
</tr>
<tr>
<td><code>sort()</code></td>
<td>对 arraylist 元素进行排序</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>将 arraylist 转换为数组</td>
</tr>
<tr>
<td><code>toString()</code></td>
<td>将 arraylist 转换为字符串</td>
</tr>
<tr>
<td><code>ensureCapacity()</code></td>
<td>设置指定容量大小的 arraylist</td>
</tr>
<tr>
<td><code>lastIndexOf()</code></td>
<td>返回指定元素在 arraylist 中最后一次出现的位置</td>
</tr>
<tr>
<td><code>retainAll()</code></td>
<td>保留 arraylist 中在指定集合中也存在的那些元素</td>
</tr>
<tr>
<td><code>containsAll()</code></td>
<td>查看 arraylist 是否包含指定集合中的所有元素</td>
</tr>
<tr>
<td><code>trimToSize()</code></td>
<td>将 arraylist 中的容量调整为数组中的元素个数</td>
</tr>
<tr>
<td><code>removeRange()</code></td>
<td>删除 arraylist 中指定索引之间存在的元素</td>
</tr>
<tr>
<td><code>replaceAll()</code></td>
<td>将给定的操作内容替换掉数组中每一个元素</td>
</tr>
<tr>
<td><code>removeIf()</code></td>
<td>删除所有满足特定条件的 arraylist 元素</td>
</tr>
<tr>
<td><code>forEach()</code></td>
<td>遍历 arraylist 中每一个元素并执行特定操作</td>
</tr>
</tbody>
</table>
<h2 id="linkedlist">LinkedList</h2>
<p><code>LinkedList</code>是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。链表可分为单向链表和双向链表。一个单向链表包含两个值：当前节点的值和一个指向下一个节点的链接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 导包 与 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> java.util.LinkedList<span style="color:#f92672">;</span> 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LinkedList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;();</span>   <span style="color:#75715e">// 普通创建方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">或者</span>
</span></span><span style="display:flex;"><span>LinkedList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">(</span>Collection<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">extends</span> E<span style="color:#f92672">&gt;</span> c<span style="color:#f92672">);</span> <span style="color:#75715e">// 使用集合创建链表
</span></span></span></code></pre></div><p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(E e)</code></td>
<td>链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>add(int index, E element)</code></td>
<td>向指定位置插入元素。</td>
</tr>
<tr>
<td><code>addAll(Collection c)</code></td>
<td>将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td>`addAll(int index, Collection c)</td>
<td>将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>addFirst(E e)</code></td>
<td>元素添加到头部。</td>
</tr>
<tr>
<td><code>addLast(E e)</code></td>
<td>元素添加到尾部。</td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>offerFirst(E e)</code></td>
<td>头部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>offerLast(E e)</code></td>
<td>尾部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空链表。</td>
</tr>
<tr>
<td><code>removeFirst()</code></td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td><code>removeLast()</code></td>
<td>删除并返回最后一个元素。</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>删除某一元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td><code>remove(int index)</code></td>
<td>删除指定位置的元素。</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>删除并返回第一个元素。</td>
</tr>
<tr>
<td><code>contains(Object o)</code></td>
<td>判断是否含有某一元素。</td>
</tr>
<tr>
<td><code>get(int index)</code></td>
<td>返回指定位置的元素。</td>
</tr>
<tr>
<td><code>getFirst()</code></td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td><code>getLast()</code></td>
<td>返回最后一个元素。</td>
</tr>
<tr>
<td><code>indexOf(Object o)</code></td>
<td>查找指定元素从前往后第一次出现的索引。</td>
</tr>
<tr>
<td><code>lastIndexOf(Object o)</code></td>
<td>查找指定元素最后一次出现的索引。</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td><code>element()</code></td>
<td>返回第一个元素。</td>
</tr>
<tr>
<td><code>peekFirst()</code></td>
<td>返回头部元素。</td>
</tr>
<tr>
<td><code>peekLast()</code></td>
<td>返回尾部元素。</td>
</tr>
<tr>
<td><code>set(int index, E element)</code></td>
<td>设置指定位置的元素。</td>
</tr>
<tr>
<td><code>clone()</code></td>
<td>克隆该列表。</td>
</tr>
<tr>
<td><code>descendingIterator()</code></td>
<td>返回倒序迭代器。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回链表元素个数。</td>
</tr>
<tr>
<td><code>listIterator(int index)</code></td>
<td>返回从指定位置开始到末尾的迭代器。</td>
</tr>
<tr>
<td><code>toArray()</code></td>
<td>返回一个由链表元素组成的数组。</td>
</tr>
<tr>
<td><code>toArray(T[] a)</code></td>
<td>返回一个由链表元素转换类型而成的数组。</td>
</tr>
</tbody>
</table>
<h2 id="hashset">HashSet</h2>
<p><code>HashSet</code> 基于 <code>HashMap</code> 来实现的，实现了 <code>Set</code> 接口，是一个不允许有重复元素的集合。<code>HashSet</code> 是<strong>无序</strong>的，即不会记录插入的顺序，<code>HashSet</code> 允许有 <code>null</code> 值。</p>
<p><code>HashSet</code> <strong>不是</strong>线程安全的， 如果多个线程尝试同时修改 <code>HashSet</code>，则最终结果是不确定的。 必须在多线程访问时显式同步对 <code>HashSet</code> 的并发访问。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 导包 与 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> java.util.HashSet<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>HashSet<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> sites <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;();</span>
</span></span></code></pre></div><p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>add(E e)</code></td>
<td style="text-align:left">如果指定的元素尚不存在，则将其添加到此集合中。</td>
</tr>
<tr>
<td style="text-align:left"><code>clear()</code></td>
<td style="text-align:left">从该集中删除所有元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>clone()</code></td>
<td style="text-align:left">返回此 <code>HashSet</code>实例的浅表副本：未克隆元素本身。</td>
</tr>
<tr>
<td style="text-align:left"><code>contains(Object o)</code></td>
<td style="text-align:left">如果此set包含指定的元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td style="text-align:left"><code>isEmpty()</code></td>
<td style="text-align:left">如果此集合不包含任何元素，则返回 <code>true</code> 。</td>
</tr>
<tr>
<td style="text-align:left"><code>iterator()</code></td>
<td style="text-align:left">返回此set中元素的迭代器。</td>
</tr>
<tr>
<td style="text-align:left"><code>remove(Object o)</code></td>
<td style="text-align:left">如果存在，则从该集合中移除指定的元素。</td>
</tr>
<tr>
<td style="text-align:left"><code>size()</code></td>
<td style="text-align:left">返回此集合中的元素数（基数）。</td>
</tr>
<tr>
<td style="text-align:left"><code>spliterator()</code></td>
<td style="text-align:left">在此集合中的元素上创建<em>late-binding</em>和<em>失败快速</em> <code>Spliterator</code> 。</td>
</tr>
</tbody>
</table>
<h2 id="linkedhashset">LinkedHashSet</h2>
<p><code>LinkedHashSet</code>是<code>HashSet</code>的子类，是有序的<code>HashSet</code>，通过链表完成。所以继承了<code>HashSet</code>所有的方法</p>
<h2 id="treeset">TreeSet</h2>
<p><code>TreeSet</code>对元素进行排序，底层是基于<code>TreeMap</code>来实现的，TreeMap底层基于红黑树（特殊的二叉树，左边叉值小，右边叉值大，有自平衡机制），存储的<strong>元素类型必须一样</strong>且元素类型的类<strong>必须实现<code>Comparable</code>接口</strong>。</p>
<p><code>TreeSet</code>存在两种排序方式：</p>
<ol>
<li>
<p>自然排序：元素类型必须实现了<code>Comparable</code>接口，且必须重写<code>compareTo()</code>方法。</p>
</li>
<li>
<p>定制排序： 在创建<code>TreeSet</code>对象的时候，传入一个<code>Comparator</code>接口的实现类，该实现类必须重写<code>compare</code>方法。</p>
</li>
</ol>
<p><strong>构造方法</strong>：</p>
<ul>
<li>
<p><code>TreeSet()</code>创建一个有自然排序功能的<code>TreeSet</code>对象。  默认自然排序是升序。</p>
</li>
<li>
<p><code>TreeSet(Collection c)</code> 构造一个包含指定集合中的元素的新树集，根据其元素的 自然排序进行排序 。  使用该构造方法，要求，集合参数c必须元素是同一种类型，且实现了<code>Comparable</code>接口的。</p>
</li>
<li>
<p><code>TreeSet(Comparator comparator)</code> 创建一个有定制排序功能的TreeSet对象。可以使用Comparator的实现类对象，也可以使用Comparator的匿名内部类。</p>
</li>
</ul>
<p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>add(E e)</code></td>
<td>如果指定的元素尚不存在，则将其添加到此集合中。</td>
</tr>
<tr>
<td><code>addAll(Collection&lt;?extends E&gt; c)</code></td>
<td>将指定集合中的所有元素添加到此集合中。</td>
</tr>
<tr>
<td><code>ceiling(E e)</code></td>
<td>返回此set中大于或等于给定元素的 null元素，如果没有这样的元素，则 null 。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>从该集中删除所有元素。</td>
</tr>
<tr>
<td><code>clone()</code></td>
<td>返回此 TreeSet实例的浅表副本。</td>
</tr>
<tr>
<td><code>contains(Object o)</code></td>
<td>如果此set包含指定的元素，则返回 true 。</td>
</tr>
<tr>
<td><code>descendingIterator()</code></td>
<td>以降序返回此集合中元素的迭代器。</td>
</tr>
<tr>
<td><code>descendingSet()</code></td>
<td>返回此set中包含的元素的逆序视图。</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>返回此集合中当前的第一个（最低）元素。</td>
</tr>
<tr>
<td><code>floor(E e)</code></td>
<td>返回此set中小于或等于给定元素的最大元素，如果没有这样的元素，则 null 。</td>
</tr>
<tr>
<td><code>headSet(E toElement)</code></td>
<td>返回此set的部分视图，其元素严格小于 toElement 。</td>
</tr>
<tr>
<td><code>headSet(E toElement, boolean inclusive)</code></td>
<td>返回此set的部分视图，其元素小于（或等于，如果 inclusive为true） toElement 。</td>
</tr>
<tr>
<td><code>higher(E e)</code></td>
<td>返回此集合中的最小元素严格大于给定元素，如果没有这样的元素，则 null 。</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>如果此集合不包含任何元素，则返回 true 。</td>
</tr>
<tr>
<td><code>iterator()</code></td>
<td>以升序返回此集合中元素的迭代器。</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回此集合中当前的最后一个（最高）元素。</td>
</tr>
<tr>
<td><code>lower(E e)</code></td>
<td>返回此集合中的最大元素严格小于给定元素，如果没有这样的元素，则 null 。</td>
</tr>
<tr>
<td><code>pollFirst()</code></td>
<td>检索并删除第一个（最低）元素，如果此组为空，则返回 null 。</td>
</tr>
<tr>
<td><code>pollLast()</code></td>
<td>检索并删除最后一个（最高）元素，如果此集合为空，则返回 null 。</td>
</tr>
<tr>
<td><code>remove(Object o)</code></td>
<td>如果存在，则从该集合中移除指定的元素。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回此集合中的元素数（基数）。</td>
</tr>
<tr>
<td><code>spliterator()</code></td>
<td>在此集合中的元素上创建late-binding和故障快速 Spliterator 。</td>
</tr>
<tr>
<td><code>subSet(E fromElement, E toElement)</code></td>
<td>返回此set的部分视图，其元素范围从 fromElement （含）到 toElement （独占）。</td>
</tr>
<tr>
<td><code>tailSet(E fromElement)</code></td>
<td>返回此set的部分视图，其元素大于或等于 fromElement 。</td>
</tr>
</tbody>
</table>
<h2 id="map">Map</h2>
<p><code>Map</code>也是一种容器的接口，里面存储的是一对一对的数据，每添加一次，添加的是两个（一对）数据，一个映射（一个Map对象）不能包含重复的键，与<code>Collection</code>并无关系；<code>Collection</code>体系，存储在都是单个单个的数据，数据之间没有关系。</p>
<p><strong><code>Map</code>的遍历方式</strong>：</p>
<ol>
<li>
<p>如果只是获取所有一个值，使用<code>values()</code>方法</p>
</li>
<li>
<p>如果只是获取所有的key，使用<code>keySet()</code>方法</p>
</li>
<li>
<p>如果获取所有的key-value，使用<code>entrySet()</code>，不要用先通过<code>keySet()</code>获取key，再用<code>get()</code>获取具体的value，这样会导致二次查询，效率低下</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Map m <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小明&#34;</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">90</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小马&#34;</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">60</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;小郭&#34;</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">60</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Set entrys <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">entrySet</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Object en <span style="color:#f92672">:</span> entrys<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 需要把en强制转成 Entry类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	Entry e <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">)</span>en<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">()+</span><span style="color:#e6db74">&#34;--&#34;</span><span style="color:#f92672">+</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="hashmap">HashMap</h2>
<p>基于<code>hashCode()</code>，底层是<code>Entry</code>键值对的数组，数组中装装的是键值对。从结构实现来讲，<code>HashMap</code>是数组+链表+红黑树实现。</p>
<p><code>HashMap</code>会根据添加的<code>key</code>的<code>hashCode</code>值与当前数组的<code>length</code>（默认是16）取模，而得到数组的下标，进而保存键值对，故<code>HashMap</code>存储的数据是无序的，因为角标是计算得出而不是按顺序排列。</p>
<p>如果<code>key</code>模<code>length</code>后，得到的下标是相等的，就会发生哈希冲突，这时候再继续判断<code>key</code>的<code>equals</code>方法，如果<code>equals</code>判断为<code>true</code>，就会将原来的键值对覆盖，如果是<code>false</code>，就会在该下标处的原来键值对后面形成链表，如果<strong>链表长度达到8个且元素总量大于64时，就形成红黑树</strong>。当<strong>删除键值对后剩余的数量小于等于6的时候，就重新将红黑树退化为链表</strong>。</p>
<p><strong>构造方法</strong>：</p>
<ul>
<li>
<p><code>HashMap()</code>构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载系数（0.75）。</p>
<p>容量16：是键值对的数组长度16</p>
<p>负载系数0.75：扩容机制是当容量达到75%的时候，开始扩容，就是创建新数组，复制元素。</p>
</li>
<li>
<p><code>HashMap(int initialCapacity)</code>创建空的 <code>HashMap</code>具有指定的初始容量<code>initialCapacity</code>和默认负载因子（0.75）。</p>
</li>
<li>
<p><code>HashMap(int initialCapacity, float loadFactor)</code> 构造一个空的 <code>HashMap</code>具有指定的初始容量和负载因子。</p>
</li>
<li>
<p><code>HashMap(Map m)</code> 创建一个<code>HashMap</code>对象，并且传入另一个<code>Map</code>对象<code>m</code>，这样先创建对象就有了与<code>m</code>相同的数据</p>
</li>
</ul>
<p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>putAll(Map m)</code></td>
<td>将传入的Map作为参数，创建一个新的HashMap对象</td>
</tr>
<tr>
<td><code>get(Object key)</code></td>
<td>根据key去获取value值,如果key不存在，则返回null</td>
</tr>
<tr>
<td><code>remove(Object key)</code></td>
<td>根据key删除当前map对象中的这一对键值对</td>
</tr>
<tr>
<td><code>remove(Object key, Object value)</code></td>
<td>只有key和value都存在的时候，才能删除</td>
</tr>
<tr>
<td><code>replace(K key, V value)</code></td>
<td>根据key替换为新的value的值</td>
</tr>
<tr>
<td><code>replace(K key, V oldValue, V newValue)</code></td>
<td>只有当key和value都存在的情况下，才能替换为新的 newValue值</td>
</tr>
<tr>
<td><code>containsKey(Object key)</code></td>
<td>判断当前map集合对象中是否包含这个key</td>
</tr>
<tr>
<td><code>containsValue(Object value)</code></td>
<td>判断当前map集合对象中是否包含这个value，包含则返回 true 。</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清除所有的键值对对象</td>
</tr>
<tr>
<td><code>isEmpty()</code></td>
<td>判段当前map对象是否是空集合 。</td>
</tr>
<tr>
<td><code>size()</code></td>
<td>获取当前Map键值对个数。</td>
</tr>
</tbody>
</table>
<p><strong><code>HashTable</code> 与 <code>HashMap</code>的区别</strong>：</p>
<ul>
<li>
<p><code>HashMap</code>可以接受<code>null</code>键值和值，而<code>HashTable</code>则不能。</p>
</li>
<li>
<p><code>HashMap</code>去掉了<code>Hashtable</code>的<code>contains</code>方法，改成<code>containsValue</code>和<code>containsKey</code>。</p>
</li>
<li>
<p><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>是Java1.2引进的<code>interface Map</code> 的一个实现。</p>
</li>
<li>
<p>最大的不同是，<code>Hashtable</code>的方法是<code>Synchronize</code>的，而<code>HashMap</code>不是，在多个线程访问<code>Hashtable</code>时，不需要自己为它的方法实现同步，而**<code>HashMap</code>就必须为之提供外同步**。</p>
</li>
<li>
<p><code>Hashtable</code>和<code>HashMap</code>采用的<code>hash/rehash</code>算法都大概一样，所以<strong>性能不会有很大的差异</strong>。</p>
</li>
</ul>
<h2 id="properties">Properties</h2>
<p><code>Properties</code> 继承于 <code>Hashtable</code>。表示一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。<code>Properties</code> 定义的实例变量，这个变量持有一个 <code>Properties</code> 对象相关的默认属性列表。</p>
<p><strong>使用场景</strong>：</p>
<ol>
<li>
<p>将内存中的数据写入到硬盘中；</p>
</li>
<li>
<p>将硬盘中的数据读取到内存中；</p>
</li>
<li>
<p>使用时需要使用 <code>Properties</code> 自己的方法，才能使<code>key</code>和<code>value</code>都是<code>String</code>类型。</p>
</li>
</ol>
<p><strong>常用方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>String getProperty(String key)</code></td>
<td>用指定的键在此属性列表中搜索属性。</td>
</tr>
<tr>
<td><code>String getProperty(String key, String defaultProperty)</code></td>
<td>用指定的键在属性列表中搜索属性，defaultProperty为不存在时的提示内容。</td>
</tr>
<tr>
<td><code>void list(PrintStream streamOut)</code></td>
<td>将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td><code>void list(PrintWriter streamOut)</code></td>
<td>将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td><code>void load(InputStream streamIn) throws IOException</code></td>
<td>从输入流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td><code>Enumeration propertyNames( )</code></td>
<td>按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td><code>Object setProperty(String key, String value)</code></td>
<td>调用 Hashtable 的方法 put。</td>
</tr>
<tr>
<td><code>void store(OutputStream streamOut, String description)</code></td>
<td>以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Properties pp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Properties<span style="color:#f92672">();</span> <span style="color:#75715e">//获得一个Properties对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		
</span></span><span style="display:flex;"><span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">setProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;XXXX&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;OOOO&#34;</span><span style="color:#f92672">);</span> <span style="color:#75715e">//给Properties对象设置值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">setProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;YYYY&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;JJJJ&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pp<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;XXXX&#34;</span><span style="color:#f92672">));</span> <span style="color:#75715e">//从Properties对象根据key获得值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>PrintStream ps <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PrintStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/qq.txt&#34;</span><span style="color:#f92672">);</span> <span style="color:#75715e">// 建立一个打印流与文件关联
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">list</span><span style="color:#f92672">(</span>ps<span style="color:#f92672">);</span> <span style="color:#75715e">// 将list方法的值持久化到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>FileInputStream fis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/easyexplore.link&#34;</span><span style="color:#f92672">)</span> <span style="color:#75715e">// 建立一个文件输入流，与对应文件相关联
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pp<span style="color:#f92672">.</span><span style="color:#a6e22e">load</span><span style="color:#f92672">(</span>fis<span style="color:#f92672">);</span> <span style="color:#75715e">// load方法讲文件中的值加载到Properties对象中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>pp<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>String property <span style="color:#f92672">=</span> pp<span style="color:#f92672">.</span><span style="color:#a6e22e">getProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;path&#34;</span><span style="color:#f92672">);</span> <span style="color:#75715e">// 获得Properties对象中的 “path” 值对应的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>property<span style="color:#f92672">);</span>
</span></span></code></pre></div><h2 id="泛型">泛型</h2>
<p>泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>
<p><strong>规则限制</strong>：</p>
<ol>
<li>泛型的类型参数只能是类类型（包括自定义类），不能是简单类型。</li>
<li>同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</li>
<li>泛型的类型参数可以有多个。</li>
<li>泛型的参数类型可以使用extends语句，例如<code>&lt;T extends superclass&gt;</code>。习惯上称为“有界类型”。</li>
<li>泛型的参数类型还可以是通配符类型。例如<code>&lt;?  extends Number&gt;</code> 表示最高可以传入的类型是Number及其子类类型</li>
</ol>
<h3 id="泛型类">泛型类</h3>
<p>一个类本质看成是一个通用的模板，在设计类的时候，其中的数据类型写一个符号，泛指所有的类型，但是不指具体的某种类型</p>
<p>当在使用模板来创建一个对象的时候可以指定自己的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Point</span><span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">数据类型</span><span style="color:#f92672">&gt;{</span>    <span style="color:#75715e">// 表示在类声明了一个符号  数据类型，是一种泛指
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#960050;background-color:#1e0010">数据类型</span> x<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">数据类型</span> y<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>  
</span></span></code></pre></div><h3 id="泛型方法">泛型方法</h3>
<p>就是把泛型类型的声明放在某个方法上面，只需将泛型参数列表置于<strong>返回值前</strong>，只能够本方法上或者内部可以使用这个符号，在调用方法的时候传入的实际参数为真实的类型。</p>
<p><strong>注</strong>：在<strong>创建数组</strong>的时候,必须要知道具体类型的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> T<span style="color:#f92672">[]</span> <span style="color:#a6e22e">getArr</span><span style="color:#f92672">(</span>T<span style="color:#f92672">[]</span> arr<span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>	T<span style="color:#f92672">[]</span> copyOf <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>T<span style="color:#f92672">[])</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">,</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>	Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>copyOf<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> copyOf<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://bruisesl.github.io/post/java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8/"><span>←</span><span>Java 线程与异常</span></a>
     
    <a class="next" href="https://bruisesl.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span>正则表达式</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2023 <a href="https://bruisesl.github.io">BruisesL&#39;s blog</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.0</a>
  </p>
</footer>

  </body>
</html>
