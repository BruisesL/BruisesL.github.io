<!DOCTYPE html>













<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>算法 - Paper</title>

  
  
  <meta name="description" content="算法   算法定义：
「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：
 问题是明确的，需要拥有明确的输入和输出定义。 解具有确定性，即给定相同输入时，输出一定相同。 具有可行性，可在有限步骤、有限时间、有限内存空间下完成。 独立于编程语言，即可用多种语言实现。      数据结构定义：
「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：
 空间占用尽可能小，节省计算机内存。 数据操作尽量快，包括数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。  数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。
  数据结构与算法的关系：
「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：
  数据结构是算法的底座。数据结构为算法提供结构化存储的数据，以及操作数据的对应方法。
  算法是发挥数据结构优势的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。
  算法有对应最优的数据结构。给定算法，一般可基于不同的数据结构实现，而最终执行效率往往相差很大。
    复杂度分析 算法效率评估 算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：找到问题解法 与 寻求最优解法。
算法效率则是主要评价维度，包括：
  时间效率，即算法的运行速度的快慢。
  空间效率，即算法占用的内存空间大小。
  注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，因此以空间换时间最为常用。
  效率评估方法&ndash;实际测试
假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况。这种评估方式能够反映真实情况，但是也存在弊端：
  难以排除测试环境的干扰因素。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。" />
  <meta name="author" content="BruisesL" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://bruisesl.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/github.svg" />
  

  
  <link rel="icon" href="https://bruisesl.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://bruisesl.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.92.2" />

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="算法" />
<meta property="og:description" content="算法   算法定义：
「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：
 问题是明确的，需要拥有明确的输入和输出定义。 解具有确定性，即给定相同输入时，输出一定相同。 具有可行性，可在有限步骤、有限时间、有限内存空间下完成。 独立于编程语言，即可用多种语言实现。      数据结构定义：
「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：
 空间占用尽可能小，节省计算机内存。 数据操作尽量快，包括数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。  数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。
  数据结构与算法的关系：
「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：
  数据结构是算法的底座。数据结构为算法提供结构化存储的数据，以及操作数据的对应方法。
  算法是发挥数据结构优势的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。
  算法有对应最优的数据结构。给定算法，一般可基于不同的数据结构实现，而最终执行效率往往相差很大。
    复杂度分析 算法效率评估 算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：找到问题解法 与 寻求最优解法。
算法效率则是主要评价维度，包括：
  时间效率，即算法的运行速度的快慢。
  空间效率，即算法占用的内存空间大小。
  注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，因此以空间换时间最为常用。
  效率评估方法&ndash;实际测试
假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况。这种评估方式能够反映真实情况，但是也存在弊端：
  难以排除测试环境的干扰因素。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bruisesl.github.io/post/%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-02-01T00:00:00+00:00" />


  
  <meta itemprop="name" content="算法">
<meta itemprop="description" content="算法   算法定义：
「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：
 问题是明确的，需要拥有明确的输入和输出定义。 解具有确定性，即给定相同输入时，输出一定相同。 具有可行性，可在有限步骤、有限时间、有限内存空间下完成。 独立于编程语言，即可用多种语言实现。      数据结构定义：
「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：
 空间占用尽可能小，节省计算机内存。 数据操作尽量快，包括数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。  数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。
  数据结构与算法的关系：
「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：
  数据结构是算法的底座。数据结构为算法提供结构化存储的数据，以及操作数据的对应方法。
  算法是发挥数据结构优势的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。
  算法有对应最优的数据结构。给定算法，一般可基于不同的数据结构实现，而最终执行效率往往相差很大。
    复杂度分析 算法效率评估 算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：找到问题解法 与 寻求最优解法。
算法效率则是主要评价维度，包括：
  时间效率，即算法的运行速度的快慢。
  空间效率，即算法占用的内存空间大小。
  注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，因此以空间换时间最为常用。
  效率评估方法&ndash;实际测试
假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况。这种评估方式能够反映真实情况，但是也存在弊端：
  难以排除测试环境的干扰因素。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。"><meta itemprop="datePublished" content="2021-02-01T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-02-01T00:00:00+00:00" />
<meta itemprop="wordCount" content="445">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="算法"/>
<meta name="twitter:description" content="算法   算法定义：
「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：
 问题是明确的，需要拥有明确的输入和输出定义。 解具有确定性，即给定相同输入时，输出一定相同。 具有可行性，可在有限步骤、有限时间、有限内存空间下完成。 独立于编程语言，即可用多种语言实现。      数据结构定义：
「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：
 空间占用尽可能小，节省计算机内存。 数据操作尽量快，包括数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。  数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。
  数据结构与算法的关系：
「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：
  数据结构是算法的底座。数据结构为算法提供结构化存储的数据，以及操作数据的对应方法。
  算法是发挥数据结构优势的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。
  算法有对应最优的数据结构。给定算法，一般可基于不同的数据结构实现，而最终执行效率往往相差很大。
    复杂度分析 算法效率评估 算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：找到问题解法 与 寻求最优解法。
算法效率则是主要评价维度，包括：
  时间效率，即算法的运行速度的快慢。
  空间效率，即算法占用的内存空间大小。
  注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，因此以空间换时间最为常用。
  效率评估方法&ndash;实际测试
假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况。这种评估方式能够反映真实情况，但是也存在弊端：
  难以排除测试环境的干扰因素。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://bruisesl.github.io">Paper</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/about/">About</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/BruisesL"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <aside>
      <time>February 1, 2021</time>
      
      <span>BruisesL</span>
      
    </aside>
    <h1>算法</h1>
  </header>
  <section class="post-content"><h2 id="算法">算法</h2>
<ul>
<li>
<p>算法定义：</p>
<p>「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：</p>
<ul>
<li>问题是<strong>明确的</strong>，需要拥有明确的输入和输出定义。</li>
<li>解具有<strong>确定性</strong>，即给定相同输入时，输出一定相同。</li>
<li>具有<strong>可行性</strong>，可在有限步骤、有限时间、有限内存空间下完成。</li>
<li><strong>独立</strong>于编程语言，即可用多种语言实现。</li>
</ul>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.png" alt="数据结构与算法"></p>
<ul>
<li>
<p>数据结构定义：</p>
<p>「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：</p>
<ul>
<li>空间占用尽可能<strong>小</strong>，节省计算机内存。</li>
<li>数据操作尽量<strong>快</strong>，包括数据访问、添加、删除、更新等。</li>
<li>提供<strong>简洁</strong>的数据表示和逻辑信息，以便算法<strong>高效</strong>运行。</li>
</ul>
<p>数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。</p>
</li>
<li>
<p>数据结构与算法的关系：</p>
<p>「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：</p>
<ul>
<li>
<p>数据结构是算法的底座。数据结构为算法提供<strong>结构化存储的数据</strong>，以及<strong>操作数据的对应方法</strong>。</p>
</li>
<li>
<p>算法是<strong>发挥数据结构优势</strong>的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。</p>
</li>
<li>
<p>算法有对应最优的数据结构。给定算法，一般可<strong>基于不同的数据结构</strong>实现，而最终<strong>执行效率往往相差很大</strong>。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="数据结构与算法的关系"></p>
<h2 id="复杂度分析">复杂度分析</h2>
<h3 id="算法效率评估">算法效率评估</h3>
<p>算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：<strong>找到问题解法</strong> 与 <strong>寻求最优解法</strong>。</p>
<p>算法效率则是主要评价维度，包括：</p>
<ol>
<li>
<p><strong>时间效率</strong>，即算法的运行速度的快慢。</p>
</li>
<li>
<p><strong>空间效率</strong>，即算法占用的内存空间大小。</p>
</li>
</ol>
<p>注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，<strong>因此以空间换时间最为常用</strong>。</p>
<ul>
<li>
<p>效率评估方法&ndash;实际测试</p>
<p>假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是<strong>找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况</strong>。这种评估方式<strong>能够反映真实情况</strong>，但是也存在弊端：</p>
<ol>
<li>
<p><strong>难以排除测试环境的干扰因素</strong>。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。</p>
</li>
<li>
<p><strong>展开完整测试非常耗费资源</strong>。随着输入数据量的大小变化，算法会呈现出不同的效率表现。比如，有可能输入数据量较小时，算法 A 运行时间短于算法 B ，而在输入数据量较大时，测试结果截然相反。因此，若想要达到具有说服力的对比结果，那么需要输入各种体量数据，这样的测试需要占用大量计算资源。</p>
</li>
</ol>
</li>
<li>
<p>效率评估方法&ndash;理论估算</p>
<p>估算方法称为「复杂度分析 Complexity Analysis」或「渐近复杂度分析 Asymptotic Complexity Analysis」。</p>
<ol>
<li><strong>复杂度分析评估随着输入数据量的增长，算法的运行时间和占用空间的增长趋势</strong>。根据时间和空间两方面，复杂度可分为「时间复杂度 Time Complexity」和「空间复杂度 Space Complexity」。</li>
<li><strong>复杂度分析克服了实际测试方法的弊端</strong>。一是<strong>独立于测试环境</strong>，分析结果适用于所有运行平台。二是可以<strong>体现不同数据量下的算法效率</strong>，尤其是可以反映大数据量下的算法性能。</li>
</ol>
</li>
</ul>
<h3 id="时间复杂度">时间复杂度</h3>
<ul>
<li>
<p>统计算法运行时间</p>
<p>运行时间能够直观且准确地体现出算法的效率水平，想要<strong>准确预估一段代码的运行时间</strong>，需要做：</p>
<ol>
<li>
<p>首先需要 <strong>确定运行平台</strong> ，包括硬件配置、编程语言、系统环境等，这些都会影响到代码的运行效率。</p>
</li>
<li>
<p>评估 <strong>各种计算操作的所需运行时间</strong> ，例如加法操作 <code>+</code> 需要 1 ns ，乘法操作 <code>*</code> 需要 10 ns ，打印操作需要 5 ns 等。</p>
</li>
<li>
<p>根据代码<strong>统计所有计算操作的数量</strong>，并将所有操作的执行时间求和，即可得到运行时间。</p>
</li>
</ol>
<p>例如：以下代码，输入数据大小为 n ，根据以上方法，可以得到算法运行时间为 6n+12 ns 。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 在某运行平台下
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">algorithm</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>  <span style="color:#75715e">// 1 ns
</span><span style="color:#75715e"></span>    a <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">// 1 ns
</span><span style="color:#75715e"></span>    a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> 2<span style="color:#f92672">;</span>  <span style="color:#75715e">// 10 ns
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 循环 n 次
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>  <span style="color:#75715e">// 1 ns ，每轮都要执行 i++
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>     <span style="color:#75715e">// 5 ns
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>但实际上， <strong>统计算法的运行时间既不合理也不现实</strong>。首先，我们不希望预估时间和运行平台绑定，毕竟算法需要跑在各式各样的平台之上。其次，我们很难获知每一种操作的运行时间，这为预估过程带来了极大的难度。</p>
</li>
<li>
<p>统计时间增长趋势</p>
<p>「时间复杂度分析」采取了不同的做法，其统计的不是算法运行时间，而是 <strong>算法运行时间随着数据量变大时的增长趋势</strong> 。</p>
<p>“时间增长趋势”这个概念比较抽象，借助一个例子来理解。设输入数据大小为 n ，给定三个算法 <code>A</code> , <code>B</code> , <code>C</code> 。</p>
<ul>
<li>
<p>算法 <code>A</code> 只有 1 个打印操作，算法运行时间不随着 n 增大而增长。我们称此算法的时间复杂度为「<strong>常数阶</strong>」。</p>
</li>
<li>
<p>算法 <code>B</code> 中的打印操作需要循环 n 次，算法运行时间随着 n 增大成线性增长。此算法的时间复杂度被称为「线性阶」。</p>
</li>
<li>
<p>算法 <code>C</code> 中的打印操作需要循环 1000000 次，但运行时间仍与输入数据大小 n 无关。因此 <code>C</code> 的时间复杂度和 <code>A</code> 相同，仍为「<strong>常数阶</strong>」。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// 算法 A 时间复杂度：常数阶
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">algorithm_A</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 算法 B 时间复杂度：线性阶
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">algorithm_B</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e">// 算法 C 时间复杂度：常数阶
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">algorithm_C</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 1000000<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><img src="/%E7%AE%97%E6%B3%95A,B,C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A2%9E%E9%95%BF%E8%B6%8B%E5%8A%BF.png" alt="算法A,B,C的时间增长趋势"></p>
<p>相比直接统计算法运行时间，时间复杂度分析的好处有：</p>
<ol>
<li>
<p><strong>时间复杂度可以有效评估算法效率</strong>。算法 <code>B</code> 运行时间的增长是线性的，在 n&gt;1 时慢于算法 <code>A</code> ，在 n&gt;1000000 时慢于算法 <code>C</code> 。实质上，只要输入数据大小 n 足够大，复杂度为「常数阶」的算法一定优于「线性阶」的算法，这也正是时间增长趋势的含义。</p>
</li>
<li>
<p><strong>时间复杂度的推算方法更加简便</strong>。在时间复杂度分析中，我们可以将统计「计算操作的运行时间」简化为统计「计算操作的数量」，这是因为，无论是运行平台还是计算操作类型，都与算法运行时间的增长趋势无关。因而，我们可以简单地将所有计算操作的执行时间统一看作是相同的“单位时间”，这样的简化做法大大降低了估算难度。</p>
</li>
<li>
<p><strong>时间复杂度也存在一定的局限性</strong>。比如，虽然算法 <code>A</code> 和 <code>C</code> 的时间复杂度相同，但是实际的运行时间有非常大的差别。再比如，虽然算法 <code>B</code> 比 <code>C</code> 的时间复杂度要更高，但在输入数据大小 n 比较小时，算法 <code>B</code> 是要明显优于算法 <code>C</code> 的。对于以上情况，我们很难仅凭时间复杂度来判定算法效率高低。然而，即使存在这些问题，计算复杂度仍然是评判算法效率的最有效且常用的方法。</p>
</li>
</ol>
</li>
<li>
<p>函数渐近上界</p>
<p>设算法「计算操作数量」为 T(n) ，其是一个关于输入数据大小 n 的函数。例如，以下算法的操作数量为 T(n) = 3 + 2n</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">algorithm</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">// +1
</span><span style="color:#75715e"></span>    a <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>  <span style="color:#75715e">// +1
</span><span style="color:#75715e"></span>    a <span style="color:#f92672">=</span> a <span style="color:#f92672">*</span> 2<span style="color:#f92672">;</span>  <span style="color:#75715e">// +1
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 循环 n 次
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// +1（每轮都执行 i ++）
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>    <span style="color:#75715e">// +1
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>T(n) 是个一次函数，说明时间增长趋势是线性的，因此易得时间复杂度是线性阶。</p>
<p>将线性阶的时间复杂度记为 O(n) ，这个数学符号被称为「大 O 记号 Big-O Notation」，代表函数 T(n) 的「渐近上界 asymptotic upper bound」。</p>
<p>我们要推算时间复杂度，本质上是在计算「操作数量函数 T(n) 」的渐近上界。它的数学定义是。</p>
<pre tabindex="0"><code>若存在正实数c和实数n0，使得对于所有的 n &gt; n0 ，均有 T(n) &lt;= c*f(n)
则可认为f(n)给出了T(n)的一个渐近上界，记为 T(n) = O(f(n))
</code></pre><blockquote>
<p>具体推算方法与常见类型：</p>
<p><a href="https://www.hello-algo.com/chapter_computational_complexity/time_complexity/">https://www.hello-algo.com/chapter_computational_complexity/time_complexity/</a></p>
</blockquote>
</li>
</ul>
<h3 id="空间复杂度">空间复杂度</h3>
<p>「空间复杂度 Space Complexity」统计<strong>算法使用内存空间随着数据量变大时的增长趋势</strong>。这个概念与时间复杂度很类似。</p>
<p>与时间复杂度不同的是，一般只关注「<strong>最差空间复杂度</strong>」。这是因为内存空间是一个硬性要求，我们必须保证在所有输入数据下都有足够的内存空间预留。</p>
<p>最差空间复杂度中的“最差”有两层含义，分别为输入数据的最差分布、算法运行中的最差时间点。</p>
<ul>
<li>
<p>算法相关空间</p>
<p>算法运行中，使用的内存空间主要有以下几种：</p>
<ol>
<li>
<p>「输入空间」用于存储算法的<strong>输入数据</strong>；</p>
</li>
<li>
<p>「暂存空间」用于存储算法<strong>运行中的变量、对象、函数上下文等数据</strong>；</p>
</li>
<li>
<p>「输出空间」用于存储算法的<strong>输出数据</strong>；</p>
</li>
</ol>
<p>Tips：通常情况下，空间复杂度统计范围是「暂存空间」+「输出空间」。</p>
<p>通常「<strong>暂存空间</strong>」分为三部分：</p>
<ol>
<li>
<p>「暂存数据」用于保存算法运行中的各种 <strong>常量、变量、对象</strong> 等。</p>
</li>
<li>
<p>「栈帧空间」用于保存调用函数的上下文数据。系统每次<strong>调用函数</strong>都会<strong>在栈的顶部</strong>创建一个栈帧，<strong>函数返回时</strong>，栈帧空间<strong>会被释放</strong>。</p>
</li>
<li>
<p>「指令空间」用于保存编译后的程序指令，<strong>在实际统计中一般忽略不计</strong>。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/* 类 */</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> val<span style="color:#f92672">;</span>
    Node next<span style="color:#f92672">;</span>
    Node<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> val <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/* 函数 */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// do something...
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">algorithm</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>        <span style="color:#75715e">// 输入数据
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>          <span style="color:#75715e">// 暂存数据（常量）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>                <span style="color:#75715e">// 暂存数据（变量）
</span><span style="color:#75715e"></span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>  <span style="color:#75715e">// 暂存数据（对象）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> function<span style="color:#f92672">();</span>       <span style="color:#75715e">// 栈帧空间（调用函数）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> a <span style="color:#f92672">+</span> b <span style="color:#f92672">+</span> c<span style="color:#f92672">;</span>         <span style="color:#75715e">// 输出数据
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><blockquote>
<p>具体推算方法与常见类型：
<a href="https://www.hello-algo.com/chapter_computational_complexity/time_complexity/">https://www.hello-algo.com/chapter_computational_complexity/time_complexity/</a></p>
</blockquote>
</li>
</ul>
</section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://bruisesl.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span>←</span><span>数据结构</span></a>
     
    <a class="next" href="https://bruisesl.github.io/post/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"><span>问题及解决办法</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2023 <a href="https://bruisesl.github.io">Paper</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.0</a>
  </p>
</footer>

  </body>
</html>
