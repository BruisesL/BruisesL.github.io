<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on BruisesL&#39;s blog</title>
    <link>https://bruisesl.github.io/post/</link>
    <description>Recent content in Posts on BruisesL&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2008–2019, Steve Francia and the lee.so; all rights reserved.</copyright>
    <lastBuildDate>Wed, 01 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://bruisesl.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaEE -- JDBC</title>
      <link>https://bruisesl.github.io/post/javaee--jdbc/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/javaee--jdbc/</guid>
      <description>JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口，用于执行SQL语句。使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。在Java中，数据库存取技术只能通过JDBC访问数据。
JDBC访问数据库的方式：
直接使用JDBC的API去访问数据库服务器(MySQL/Oracle) 间接地使用JDBC的API去访问数据库服务器 public class JDBCTest1 { @Test public void testCreatJDBC() throws SQLException, ClassNotFoundException { final String URL = &amp;#34;jdbc:mysql:///test&amp;#34;; final String user = &amp;#34;root&amp;#34;; final String password = &amp;#34;root123456&amp;#34;; // 1.注册加载驱动程序 // 使用反射注册,源码中有静态代码块new Driver对象 Class.forName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); // 在mySQL 5 版本后，会自动注册，不需要手动注册 // 2.获得数据库连接 Connection connection = DriverManager.getConnection(URL, user, password); // 3.获取执行对象 Statement stmt = connection.createStatement(); // 4.执行sql查询语句，返回结果集 ResultSet rs = stmt.executeQuery(&amp;#34;SELECT * FROM emp&amp;#34;); // 5.如果有数据，rs.next()返回true while (rs.next()){ System.</description>
    </item>
    
    <item>
      <title>JaveEE 介绍</title>
      <link>https://bruisesl.github.io/post/javaee%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/javaee%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF/</guid>
      <description>Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。狭义的 Java EE 是 Sun 公司为企业级应用推出的标准平台，用来开发B/S架构软件，可以说是一个框架，也可以说是一种规范。广义的 Java EE 包含各种框架，其中最重要的就是 Spring 全家桶。Spring 诞生之初是为了改进 Java EE 开发的体验，后来逐渐成为了 Java Web 开发的实际标准。
JavaEE主要技术 JavaEE 目前有十三种核心技术。它们分别是：JDBC、JNDI、EJB、RMI、Servlet、JSP、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。
简单介绍下需要重点关注的技术。
JDBC Java 数据库连接，（Java Database Connectivity，JDBC）是 Java 语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。
JNDI Java 命名和目录接口（Java Naming and Directory Interface，JNDI），是 Java 的一个目录服务应用程序界面（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。
EJB 企业级 JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的服务器端可被管理组件。不过这个东西在 Spring 问世后便被替代了。
Servlet Servlet（Server Applet），是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。
狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。</description>
    </item>
    
    <item>
      <title>JavaBean</title>
      <link>https://bruisesl.github.io/post/javabean/</link>
      <pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/javabean/</guid>
      <description>JavaBean JavaBean 既不是 Applet，也不是 Application，从本质上来说，JavaBean 就是一组用于构建可重用组件的 Java 类库。与其他任何 Java 类一样，JavaBean 也是由属性和方法组成的。
JavaBean 的属性都具有 private 特性，方法具有 public 特性，方法是 JavaBean 的对外接口。
规范：
必须有domain包，编程规范/良好的编程习惯。
必须是具体的和公共的，访问权限最大化，非抽象的。
必须有公有无参构造，方便框架或底层通过反射创建对象。
必须有相应公有的setter、getter方法，方便设置和获取属性/el表达式。
建议对象属性私有化，控制直接操作对象属性。
建议对象属性使用包装类，控制直接操作对象属性。
一般JavaBean属性以小写字母开头，驼峰命名格式，相应的 getter/setter 方法是 get/set 接上首字母大写的属性名。例如：属性名为userName，其对应的 getter/setter 方法是 getUserName/setUserName。
但是，还有一些特殊情况：
如果属性名的第二个字母大写，那么该属性名直接用作 getter/setter 方法中 get/set 的后部分，就是说大小写不变。例如属性名为uName，方法是 getuName/setuName。
如果前两个字母是大写（一般的专有名词和缩略词都会大写），也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为URL，方法是 getURL/setURL。
如果首字母大写，也是属性名直接用作 getter/setter 方法中 get/set 的后部分。例如属性名为Name，方法是getName/setName，这种是最糟糕的情况，会找不到属性出错，因为默认的属性名是name。
属性名/类型 getter 方法 setter 方法 xcoordinate/Double public Double getXcoordinate() public void setXcoordinate(Double newValue) xCoordinate/Double public Double getxCoordinate() public void setxCoordinate(Double newValue) XCoordinate/Double public Double getXCoordinate() public void setXCoordinate(Double newValue) Xcoordinate/Double 不允许 不允许 注：类中的属性为对象属性（字段），getter和setter⽅法上的属性为Bean属性（JavaBean属性），其中getter⽅法上的属性称之为可读属性，setter⽅法上⾯的属性称之为可写属性。</description>
    </item>
    
    <item>
      <title>反射与注解</title>
      <link>https://bruisesl.github.io/post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/</guid>
      <description>反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制，反射被视为动态语言的关键。
注：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）
Java反射的原理就是获取Class对象（类在运⾏时叫字节码对象java.lang.Class）然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。
优点：
⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）
缺点：
破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）
反射的使用 字节码对象的获取⽅式：
类名.class
对象名.getClass()
Class.forName(全类名)
public class TestReflect { /** * Constructor&amp;lt;?&amp;gt;[] getConstructors()：返回所有公共构造方法对象的数组 */ @Test public void testContructor1() throws Exception { //1.获取Student类的Class对象 Class&amp;lt;?&amp;gt; clazz = Class.forName(&amp;#34;reflect.constructor.Student&amp;#34;); //2.获取clazz的所有的公有构造方法 Constructor&amp;lt;?&amp;gt;[] constructors = clazz.getConstructors(); //3.遍历打印所有的构造方法 for (Constructor&amp;lt;?&amp;gt; constructor:constructors) { System.out.println(constructor); } } /** * Constructor&amp;lt;?&amp;gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有) */ @Test public void testContructor2() throws Exception { //1.获取Student类的Class对象 Class&amp;lt;?&amp;gt; clazz = Class.forName(&amp;#34;reflect.constructor.Student&amp;#34;); //2.获取clazz的所有的公有构造方法 Constructor&amp;lt;?&amp;gt;[] Constructors = clazz.getDeclaredConstructors(); //3.遍历打印所有的构造方法 for (Constructor&amp;lt;?</description>
    </item>
    
    <item>
      <title>Java设计模式</title>
      <link>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。
根据设计模式的参考书 **Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）**中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。
设计模式的六大原则 开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，需要使用接口和抽象类。
里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。
接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。
设计模式分类 创建型模式：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
单例模式（Singleton Pattern） 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式：这些设计模式特别关注对象之间的通信。</description>
    </item>
    
    <item>
      <title>单元测试与文件解析</title>
      <link>https://bruisesl.github.io/post/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid>
      <description>单元测试 测试的目的是尽可能多的发现软件中存在的BUG，而不是为了隐藏BUG。事实上测试有很多种类，比如：边界测试，压力测试，性能测试等。
测试的分类：
黑盒测试：
黑盒测试也叫功能测试，主要关注软件每个功能是否实现，并不关注软件代码是否有错误。测试人员完全不考虑程序内部的逻辑结构和内部特性。
白盒测试：
白盒测试与黑盒测试相反，白盒测试主要检查软件内部逻辑结构、设计等是否符合规定。
用代码来测试你的代码。
灰盒测试：
灰盒测试是介于黑盒和白盒之间的一种测试，既关注功能也关注内部逻辑的实现，但并没有白盒测试那么细致。需要灰盒测试的目的是因为白盒测试效率较低。
单元测试：
单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。比如一个方法是否正确，比如是否达到想要的效果等。也是最常用的一种方式。实际开发中，需要严格要求单元测试必须约束到最小颗粒（最小的业务逻辑）。
JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。JUnit是给开发者提供的工具类，单元测试目前有JUnit3、JUnit4、JUnit5三个版本，每个版本测试方法有微小区别，目前使用最广泛的就是JUnit4。
官网地址 官方入门文档 官方github
编写规范 单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试； 每个单元测试应当互相独立，不依赖运行的顺序； 测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为0，null，空字符串&amp;quot;&amp;quot;等情况。 常用注解 @Test
在JUnit3中，是通过对测试类和测试方法的命名来确定是否是测试，且所有的测试类必须继承JUnit的测试基类。在JUnit4中，定义一个测试方法变得简单很多，只需要在方法前加上@Test就行了。
注：测试方法必须是public void，即公共、无返回数据。可以抛出异常。
@Ignore
当暂时不运行某些测试方法\测试类，可以在方法前加上这个注解。在运行结果中，JUnit会统计忽略的用例数，来提醒你。但是不建议经常这么做，因为这样的坏处是，容易忘记去更新这些测试方法，导致代码不够干净，用例遗漏。使用此标注的时候不能与其它标注一起使用，如：和@Test 标注一起使用，那就没用了。
@BeforeClass
当运行几个有关联的用例时，可能会在数据准备或其它前期准备中执行一些相同的命令，这个时候为了让代码更清晰，更少冗余，可以将公用的部分提取出来，放在一个方法里，并为这个方法注解@BeforeClass。意思是在测试类里所有用例运行之前，运行一次这个方法。例如创建数据库连接、读取文件等。
注：方法名必须是public static void，即公开、静态、无返回。这个方法只会运行一次。
@AfterClass
跟@BeforeClass对应，在测试类里所有用例运行之后，运行一次。用于处理一些测试后续工作，例如清理数据，恢复现场。
注：方法必须是public static void，即公开、静态、无返回。这个方法只会运行一次。
@Before
与@BeforeClass的区别在于，@Before不止运行一次，它会在每个用例运行之前都运行一次。主要用于一些独立于用例之间的准备工作。
比如两个用例都需要读取数据库里的用户A信息，但第一个用例会删除这个用户A，而第二个用例需要修改用户A。那么可以用@BeforeClass创建数据库连接。用@Before来插入一条用户A信息。
注：必须是public void，不能为static。不止运行一次，根据用例数而定。
@After：与@Before对应。
@Runwith
概念：测试方法、测试类、测试集、测试运行器。
测试方法：就是用@Test注解的一些函数。
测试类是包含一个或多个测试方法的一个Test.java文件。
测试集是一个suite，可能包含多个测试类。
测试运行器则决定了用什么方式偏好去运行这些测试集/类/方法。
@Runwith是放在测试类名之前，用来确定这个类怎么运行的。也可以不标注，会使用默认运行器。
常见运行器：
@RunWith(Parameterized.class) 参数化运行器，配合@Parameters使用junit的参数化功能 @RunWith(Suite.class) @SuiteClasses({ATest.class,BTest.class,CTest.class})测试集运行器配合使用测试集功能 @RunWith(JUnit4.class) JUnit4的默认运行器 @RunWith(JUnit38ClassRunner.class) 用于兼容JUnit3.8的运行器 其它运行器具备更多功能。例如@RunWith(SpringJUnit4ClassRunner.class)集成了spring的一些功能 @Parameters： 用于使用参数化功能。
测试的生命周期 **@BeforeClass**注解修饰的方法（该方法要用static修饰）会在所有方法运行前被执行，且只执行一次，通常用来为后面测试方法的准备工作，如加载配置、进行数据库的连接等。父类的@BeforeClass注解方法会在子类的@BeforeClass注解方法执行前执行。
**@Before**注解修饰的方法会在每个测试方法执行前执行一次，父类@Before修饰的方法会在子类@Before修饰的方法执行前执行。
**@After**注解修饰的方法会在每个测试方法执行后执行一次，父类@After修饰的方法会在子类@After修饰的方法执行后执行。
**@AfterClass**注解修饰的方法（该方法要用static修饰）会在所有方法执行结束后执行一次，且也只执行一次，通常用来对资源进行释放，比如数据库连接的关闭等，无论测试用例里的其他方法有没有抛出异常，该方法最终都会被执行。而且父类中的被@AfterClass注解方法修饰的方法会在子类的@AfterClass注解修饰的方法执行之后才会被执行。
jar包 导入jar包的方法：</description>
    </item>
    
    <item>
      <title>流(Stream)、文件(File)和IO</title>
      <link>https://bruisesl.github.io/post/%E6%B5%81stream%E6%96%87%E4%BB%B6file%E5%92%8Cio/</link>
      <pubDate>Mon, 20 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E6%B5%81stream%E6%96%87%E4%BB%B6file%E5%92%8Cio/</guid>
      <description>流(Stream) Java 8 API添加了一个新的抽象称为流Stream，可以以一种声明的方式处理数据。
Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果。
+--------------------+ +------+ +------+ +---+ +-------+ | stream of elements +-----&amp;gt; |filter+-&amp;gt; |sorted+-&amp;gt; |map+-&amp;gt; |collect| +--------------------+ +------+ +------+ +---+ +-------+ 以上的流程转换为 Java 代码为：
List&amp;lt;Integer&amp;gt; transactionsIds = widgets.stream() .filter(b -&amp;gt; b.getColor() == RED) .sorted((x,y) -&amp;gt; x.getWeight() - y.getWeight()) .mapToInt(Widget::getWeight) .sum(); Stream是一个来自数据源的元素队列并支持聚合操作：
元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。 Stream操作有两个基础的特征：
Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行laziness和短路short-circuiting。 内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式Visitor实现。 生成流 在 Java 8 中, 集合接口有两个方法来生成流：</description>
    </item>
    
    <item>
      <title>Java 线程与异常</title>
      <link>https://bruisesl.github.io/post/java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Sat, 18 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8/</guid>
      <description>异常 异常发生的原因通常包含以下几大类：
用户输入了非法数据。
要打开的文件不存在。
网络通信时连接中断，或者JVM内存溢出。
三种类型的异常：
检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。
Exception 类的层次 所有的异常类是从 java.lang.Exception 类继承的子类。
Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。Error 用来指示运行时环境发生的错误。
Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。例如，JVM 内存溢出。一般程序不会从错误中恢复。
异常类有两个主要的子类：IOException 类和 RuntimeException 类。
内置异常类 Java 定义了一些异常类在 java.lang 标准包中，标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。
非检查性异常
异常 描述 ArithmeticException 当出现异常的运算条件时，抛出此异常。例如，一个整数&amp;quot;除以零&amp;quot;时，抛出此类的一个实例。 ArrayIndexOutOfBoundsException 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 ArrayStoreException 试图将错误类型的对象存储到一个对象数组时抛出的异常。 ClassCastException 当试图将对象强制转换为不是实例的子类时，抛出该异常。 IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。 IllegalMonitorStateException 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 IllegalStateException 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 IllegalThreadStateException 线程没有处于请求操作所要求的适当状态时抛出的异常。 IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 NegativeArraySizeException 如果应用程序试图创建大小为负的数组，则抛出该异常。 NullPointerException 当应用程序试图在需要对象的地方使用 null 时，抛出该异常 NumberFormatException 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 SecurityException 由安全管理器抛出的异常，指示存在安全侵犯。 StringIndexOutOfBoundsException 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。 UnsupportedOperationException 当不支持请求的操作时，抛出该异常。 java.</description>
    </item>
    
    <item>
      <title>集合框架</title>
      <link>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 18 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <description>集合框架 早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。
虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。
集合框架被设计成要满足以下几个目标：
该框架必须是高性能的。基本集合（动`态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList**, **HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。
从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合Collection，存储一个元素集合，另一种是图Map，存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。
集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。
接口 接口名称 接口描述 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和Set)。Collection 接口存储一组不唯一，无序的对象。Collection接口才可以使用foreach循环。 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引（元素在List中位置，类似于数组的下标）来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 Set 接口 Set 接口具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 SortedSet 接口 继承于Set保存有序的集合。 Map接口 Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 Map.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://bruisesl.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 15 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式：Regex(Regular Expression)就是字符串校验的机制，它是跨平台，跨语言的：Java/JS/c++/sql
按需求校验做一些要求判断，例如：账号规范、密码强度、身份证、电话号码/邮箱等。
语法：
取值范围： [A-Z] 匹配26个大写字母中的一个
[a-z]` 匹配26个小写字母中的一个
[0-9] 匹配0至9数字中的一个
[A-Za-z0-9] 匹配26个大写字母、26个小写字母和0至9数字中的一个
[ajgu]匹配ajgu中任意一个字符。如果是不连续的取值，则将字符全都写上
[汉字]匹配是有&amp;quot;汉字&amp;quot;两个字中的一个
\d等价于[0-9]匹配一个任意数字
\D等价于[^0-9]	匹配一个任意非数字字符	^是除此之外
\w等价于[A-Za-z_0-9]匹配任意一个字符
\W等价于[^A-Za-z_0-9]匹配除了A-Za-z_0-9之外的任意一个字符
取值的个数：
?等价于匹配长度{0, 1} 0&amp;lt;= 个数 &amp;lt;=1	例如：[A-Z]?表示匹配A-Z中任意0~1个字符
*等价于匹配长度{0, } 个数 &amp;gt;= 0
+等价于匹配长度{1,} 个数 &amp;gt;= 1
{n, m} 匹配长度在n到m之间 n&amp;lt;= 个数 &amp;lt;=m 例如：[A-Z]{2, 6}
{n, } 匹配长度大于等于n n&amp;lt;= 个数
{n} 匹配n个
常用运算符与表达式：
^ 表示正则表达式开始（可写可不写），匹配输入字符串开始的位置。如果是在取值范围[]中使用，则表示除了&amp;hellip;
$ 表示正则表达式结尾（可写可不写），匹配输入字符串结尾的位置 如果正则表达式使用了^$表示全匹配，包括顺序 加^$的话就代表把整个要匹配的字符串当成一个整体做一次匹配， 而不加则一个字符串可以匹配多次，只能代表这个字符串中有符合条件的并不代表改字符串符合条件
[a-z] 可以用来匹配任意位置上的小写字母: &amp;ldquo;&amp;hellip;a&amp;hellip;&amp;rdquo;
^[a-z] 只能匹配以小写字母为行首的行: &amp;ldquo;a&amp;hellip;&amp;rdquo;
[a-z]$ 只能匹配以小写字母为行尾的行: &amp;ldquo;&amp;hellip;a&amp;rdquo;
^[a-z]$ 只能匹配只有一个小写字母的行: &amp;ldquo;a&amp;hellip;a&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Java 常用类</title>
      <link>https://bruisesl.github.io/post/java%E5%B8%B8%E7%94%A8%E7%B1%BB/</link>
      <pubDate>Tue, 14 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java%E5%B8%B8%E7%94%A8%E7%B1%BB/</guid>
      <description>String类 String类是一个特殊的对象，适用于描述字符串事物的，一旦被初始化就不可以被改变，可以进行字符串的大小写转换，分割字符串等字符串的操作。
String底层是final类型的char[]，是不可修改的。
String str1 = null;// 表示str1没有引用地址 String str2 = &amp;#34;&amp;#34;;// 表示str2对象引用了在常量池中创建了一个空字符串常量 String str3 = new String();// 表示str3对象引用了在堆中创建了一个空字符串常量 String	str4 = str1 + &amp;#34;a&amp;#34;; // 会创建StringBuilder的新对象，本质是调用了StringBuilder的apend()方法拼接 将其他类型转换为String类型不同方式效率对比：
toString() &amp;gt; String.valueOf(Object obj) &amp;gt; +
因为+号，底层先将字符串对象转换为StringBuilder对象，然后调用StringBuilder对象的append追加字符串方法，再调用toString方法，转换为String对象。
常量池 放字符串常量的地方，JDK8后是放在堆中，当创建字符串对象是字面量（直接是= &amp;quot; &amp;ldquo;）的时候，会优先从常量池中查找，是否有该字符串对象，如果有，则会直接将常量池中的地址赋值给该String对象；如果没有，则会在常量池创建对象，然后将对象常量池的地址给String对象保存。
当创建字符串对象用new创建，会优先从常量池中查找，是否有该字符串对象，如果有，则会直接将常量池中的地址赋值给该String对象在堆中的地址；如果没有，则会在常量池创建对象，然后将对象常量池的地址给String对象在堆中保存
String常用方法 length() 字符串的长度
char chars[]={&amp;#39;a&amp;#39;,&amp;#39;b&amp;#39;,&amp;#39;c&amp;#39;}; String s=new String(chars); int len=s.length(); charAt() 截取一个字符
char ch; ch=&amp;#34;abc&amp;#34;.charAt(1); // 返回&amp;#39;b&amp;#39; getChars() 截取多个字符
void getChars(int sourceStart,int sourceEnd,char target[],int targetStart) sourceStart指定了子串开始字符的下标，sourceEnd指定了子串结束后的下一个字符的下标。因此， 子串包含从sourceStart到sourceEnd-1的字符。接收字符的数组由target指定，target中开始复制子串的下标值是targetStart。
String s=&amp;#34;this is a demo of the getChars method.</description>
    </item>
    
    <item>
      <title>修饰符与关键字</title>
      <link>https://bruisesl.github.io/post/%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Thu, 02 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E4%BF%AE%E9%A5%B0%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>修饰符 修饰符用来定义类、方法或者变量，通常放在语句的最前端。Java语言提供了很多修饰符，主要分为以下两类：
访问修饰符 非访问修饰符 访问控制修饰符 可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。
default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
public : 对所有类可见。使用对象：类、接口、变量、方法。
protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。
修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（见protected说明） N default Y Y Y N N private Y N N N N default:
使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。
String version = &amp;#34;1.5.1&amp;#34;; boolean processOrder() { return true; } private:</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>https://bruisesl.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向对象(Object Oriented)是软件开发方法，一种编程范式。把数据及对数据的操作方法放在一起，作为一个相互依存的整体——对象。对同类对象抽象出其共性，形成类。类中的大多数数据，只能用本类的方法进行处理。类通过一个简单的外部接口与外界发生关系，对象与对象之间通过消息进行通信。程序流程由用户在使用中决定。对象即为人对各种具体物体抽象后的一个概念，人们每天都要接触各种各样的对象，如手机就是一个对象。
项目名称 面向对象程序设计 面向过程程序设计（也叫结构化编程） 定义 面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。 面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现mian()函数中所要用到的其他方法。 特点 封装、继承、多态 算法+数据结构 优势 适用于大型复杂系统，方便复用、 适用于简单系统，容易理解 劣势 比较抽象、性能比面向过程低 难以应对复杂系统，难以复用，不易维护、不易扩展 对比 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 设计语言 Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等 C、Fortran 面向对象的基本特性
唯一：每个对象都有自身唯一的标识，通过这种标识，可找到相应的对象。在对象的整个生命期中，它的标识都不改变，不同的对象不能有相同的标识。
抽象：抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。
继承：继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。
继承性是面向对象程序设计语言不同于其它语言的最重要的特点，是其他语言所没有的。
在类层次中，子类只继承一个父类的数据结构和方法，则称为单重继承。
在类层次中，子类继承了多个父类的数据结构和方法，则称为多重继承，Java仅支持单继承，C++支持均支持。
在软件开发中，类的继承性使所建立的软件具有开放性、可扩充性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建工作量，增加了代码的可重用性。
多态：多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。
多态性允许每个对象以适合自身的方式去响应共同的消息。
多态性增强了软件的灵活性和重用性。
类与对象 类(Class) 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。
格式：
访问修饰符 class 类名 { 特征 行为 } // 注: 特征和行为都称为该类的成员; 一个业务类分为静态与动态部分，静态部分为成员变量，动态部分为方法
设计业务类时不能用main方法
public class Student{ /** String name : 姓名 成员变量 */ String name; /** int age : 年龄 成员变量 */ int age; /** String sex : 性别 成员变量 */ String sex; /** * 动态部分：方法 */ /** study是方法：成员方法 */ public void study(){ System.</description>
    </item>
    
    <item>
      <title>Java 方法详解</title>
      <link>https://bruisesl.github.io/post/java-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sat, 14 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
      <description>什么是方法 Java 方法是语句的集合，他们在一起执行一个功能
方法是解决一类问题的步骤的 有序组合
方法包含于 类 或 对象 中
方法在程序中被创建，在其他地方被引用
System.out.printLn() //System类 里的标准 对象out 中的 方法printLn() 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，即一个方法只完成一个功能，这样利于我们后期的扩展。
public class Demo { //main方法 public static void main(String[] args) { int sum = add(1,2); System.out.println(sum); System.out.println(&amp;#34;=====================&amp;#34;); test(); } //加法 public static int add(int a,int b){ return a + b; } public static void test(){ int i = 0; while (i &amp;lt; 10) { i++; System.out.println(i); if (i == 3) { break; } } } } 方法的定义及调用 Java 是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：</description>
    </item>
    
    <item>
      <title>Java 流程控制</title>
      <link>https://bruisesl.github.io/post/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>用户交互Scanner 之前学习的基本语法中并没有实现程序和人的交互，Java提供了一个工具类，可以获取用户的输入。java.util.Scanner是Java5的新特征，可以通过Scanner类来获取用户的输入。
语法
Scanner s = new Scanner(System.in) 通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext() 与 hasNextLine() 判断是否还有输入的数据。
public class Demo01 { public static void main(String[] args) { //创建一个扫描器对象，用于接收键盘数据 Scanner scanner = new Scanner(System.in); System.out.println(&amp;#34;使用next方法接收：&amp;#34;); //判断用户是否输入字符串 if (scanner.hasNext()){ //使用next方式接收 String str = scanner.next(); System.out.println(&amp;#34;输入的内容为：&amp;#34;+str); } //凡事属于IO流的类，如果不关会一直占用资源 scanner.close(); } } tips：
next():
一定要读取到有效字符后才可以结束输入
对输入有效字符前遇到的空白，next() 方法会自动将其去掉
只有输入有效字符后，才将其后面输入的空白作为分隔符或结束符
next() 不能得到带有空格的字符串
nextLine():
以 Enter 为结束符，也就是说 nextLine() 方法返回的是输入回车之前的所有字符
可以获得空白
练习
public class Demo03 { public static void main(String[] args) { Scanner scanner = new Scanner(System.</description>
    </item>
    
    <item>
      <title>Java 基础语法</title>
      <link>https://bruisesl.github.io/post/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Wed, 04 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>注释 Java中注释有三种：单行注释、多行注释、文档注释 public class HelloWorld { public static void main(String[] args) { // 单行注释 System.out.println(&amp;#34;Hello,World!&amp;#34;); // 输出一个HelloWorld /* * 多行注释, * 可以注释一段文字 */ /* 文档注释：JavaDoc /**回车 * 用法： * 1.用在类的外面，用于对类解释说明 * 2.写在方法上面，对方法解释说明 * 3.解释说明成员变量 */ /** * @Description HelloWorld * @Author BruisesL */ } } 标识符 Java所有的组成部分都需要名字。类名、变量名、以及方法名都被称为标识符。
所有的标识符都应该以 字母(A-Z 或者 a-z)、美元符($)、下划线(_) 开始
首字符之后可以是 字母(A-Z 或者 a-z)、美元符($)、下划线(_) 或数字的任何字符 组合
不能使用关键字作为变量名或方法名
标识符是大小写敏感的
类名命名必须大驼峰。大驼峰：首字母大写，后面每个单词首字母大写。 例如：UserManagement
方法名、变量名小驼峰。小驼峰：首字母小写，后面每个单词首字母大写
例如：userName
合法标识符举例：age、 $salary、_value、__1_value
非法标识符举例：123abc、-salary、 #abc
关键字
分隔符 分号（ ; ）：语句的分割，表示一句话结束，好比使用的句号。</description>
    </item>
    
    <item>
      <title>Java 基础介绍</title>
      <link>https://bruisesl.github.io/post/java-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/java-%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</guid>
      <description>Jave的诞生 1972年C诞生
优点：贴近硬件，运行极快，效率极高
开发：操作系统，编译器，数据库，网络系统等
问题：指针和内存管理
1982年C++诞生
特点：面对对象
优点：兼容C
开发：图形领域、游戏等
1995年Java诞生
特点：语法像C，没有指针和内存管理，具有真正的可以执行（编写一次，到处运行），面向对象，类型安全，高质量的类库
要求：需要安装JVM（Java虚拟机）
产品：
Java2标准版(J2SE):占领桌面
Java2移动版(J2ME):占领手机
Java2企业版(J2EE):占领服务器
基于Java开发的平台，系统，工具：
构建工具：Ant，Maven，Jekins 应用服务器：Tomcat，Jetty，Jboss，Websphere，Weblogic Web开发：Struts，Spring，Hibernate，myBatis 开发工具：Eclipse，Netbean，intellij idea，Jbuilder 大数据领域：Hadoop 手机端：Android Java的特性和优势 简单性（C++语法纯净版，无头文件，无指针运算）
面向对象（重点放在对象以及对象之间的接口上，以人的思维写程序）
可移植性（可跨平台移植）
高性能（即时编译，效率接近C++）
分布式（为网络分布式所设计，可通过URL访问网络资源）
动态性（反射机制）
多线程（带来更好的交互性能）
安全性（可构建防病毒，防篡改的系统，由于去除了内存与指针的管理，Java在运行前检查内存）
健壮性
Java的三大版本 JavaSE：标准版（桌面程序、控制台开发） JavaME：嵌入式开发（手机端，小家电，目前基本不会使用） JavaEE：企业级开发（web端、服务器开发）
JDK、JRE、JVM JDK : Java Development Kit （Java开发工具）
JRE : Java Runtime Environment （Java运行环境）
JVM : Java Virtual Machine （Java虚拟机）
Java开发环境搭建 JDK下载、安装与卸载
安装（Mac M1）
需要安装适配 Arm 架构的 jdk，选择LTS版本的Java进行下载，下载完成后安装，在terminal执行查看版本号
java -version azul JDK官网下载链接
https://www.azul.com/downloads/?package=jdk#download-openjdk</description>
    </item>
    
    <item>
      <title>计算机基础</title>
      <link>https://bruisesl.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</guid>
      <description>计算机的构成 计算机由硬件+软件构成
硬件的构成为冯诺依曼体系结构，最简单的组成为CPU、内存、主板
软件的构成分为系统软件和应用软件
系统软件:DOS (Disk Operating System) , Windows, Linux, Mac, Android, IOS
应用软件:WPS, QQ, 微信等
冯诺依曼体系结构 I/O设备(input/output设备)：即输入输出设备，输入设备例如键盘、鼠标，输出设备例如显示器、音响等 CPU主要由运算器和控制器组成 运算：数据由输入设备进入存储器，存储器将数据传入运算器进行运算，在得出结果后返回存储器，存储器再将数据通过输出设备输出。 计算机语言发展史 第一代语言&amp;ndash;机器语言 计算机的基本计算方式是基于二进制的方式 第二代语言&amp;ndash;汇编语言 解决人类无法读懂机器语言的问题 指令替代二进制 第三代语言&amp;ndash;高级语言 大体分为：面向过程和面向对象两大类 C语言是面向过程的语言，C++、Java是面向对象的语言 </description>
    </item>
    
    <item>
      <title>DOS命令</title>
      <link>https://bruisesl.github.io/post/dos%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/dos%E5%91%BD%E4%BB%A4/</guid>
      <description>#盘符切换 C: #查看当前目录下的所有文件 dir #切换目录 cd (change directory)实例目录为F盘下user文件夹 跨盘符切换 cd /d f:\user 返回上一级 cd .. 进入目录 cd user #清理屏幕 cls (clear screen) #退出终端 exit #查看电脑ip ipconfig #ping 命令（获取网站ip） ping www.baidu.com #打开电脑工具（直接输入软件名称缩写） clac 计算器 mspaint 画图 notepad 记事本 #文件操作 md test 创建文件夹（文件夹名称tese） cd&amp;gt;a.txt 创建文件（文件为名字是a的txt文件） del a.txt 删除文件 rd test 删除文件夹（需进入有该文件夹的目录再进行删除，且文件夹需要为空） </description>
    </item>
    
    <item>
      <title>数据库概述</title>
      <link>https://bruisesl.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E8%AF%AD%E6%B3%95/</guid>
      <description>数据库概述 数据库，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的资料执行新增、截取、更新、删除等操作。
所谓数据库是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成，底层。
数据库管理系统 数据库管理系统（Database Management System，简称DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的数据库模型来作分类，例如关系式、XML；或依据所支持的电脑类型来作分类，例如服务器聚类、移动电话；或依据所用查询语言来作分类，例如SQL、XQuery；或依据性能冲量重点来作分类，例如最大规模、最高执行速度；亦或其他的分类方式。不论使用哪种分类方式，一些DBMS能够跨类别，例如，同时支持多种查询语言。
数据库的分类 随着数据库技术与其他分支学科技术的结合，出现了多种新型数据库，例如：与分布处理技术结合产生的分布式数据库、与并行处理技术结合产生的并行数据库、与人工智能结合产生的演绎数据库、与多媒体技术结合产生的多媒体数据库。另外，数据库技术应用于特定的领域，出现了工程数据库、 地理数据库、统计数据库、空间数据库等特定领域数据库。
关系数据库：
关系型数据库是信息的集合，它以预定义的关系组织数据，数据存储在一个或多个由列和行构成的表（或“关系”）中，用户可以轻松查看和理解不同数据结构之间的关系。 关系是不同表之间的逻辑连接，根据这些表之间的交互建立。
MySQL
MariaDB（MySQL的代替品）
Percona Server（MySQL的代替品）
PostgreSQL
Microsoft Access
Microsoft SQL Server
Google Fusion Tables
FileMaker
Oracle数据库
Sybase
dBASE
Clipper
FoxPro
foshub
几乎所有的数据库管理系统都配备了一个开放式数据库连接（ODBC）驱动程序，令各个数据库之间得以互相集成。
非关系型数据库（NoSQL）：
Not only SQL，是对不同于传统的关系数据库的数据库管理系统的统称，其数据存储可以不需要固定的表格模式以及元数据（metadata），也经常会避免使用SQL的JOIN操作，一般有水平可扩展性的特征。
BigTable（Google）
Cassandra
MongoDB
CouchDB
Redis
键值数据库：
Apache Cassandra（为Facebook所使用）：高度可扩展
Dynamo
LevelDB（Google）
数据库模型 物件模型
层次模型（轻量级数据访问协议）
网状模型（大型数据储存）
满足下面两个条件的基本层次联系的集合为网状模型。
允许一个以上的结点无双亲； 一个结点可以有多于一个的双亲。 关系模型
面向对象模型
半结构化模型
平面模型（表格模型，一般在形式上是一个二维阵列。如表格模型数据Excel)
架构 (Schema) 资料库的架构可以大致区分为三个概括层次：内层、概念层和外层。
内层：最接近实际储存体，亦即有关资料的实际储存方式。 外层：最接近使用者，即有关个别使用者观看资料的方式。 概念层：介于两者之间的间接层。[9] 数据库索引 资料索引的观念由来已久，像是一本书前面几页都有目录，目录也算是索引的一种，只是它的分类较广，例如车牌、身份证字号、条码等，都是一个索引的号码，当我们看到号码时，可以从号码中看出其中的端倪，若是要找的人、车或物品，也只要提供相关的号码，即可迅速查到正确的人事物。
另外，索引跟栏位有著相应的关系，索引即是由栏位而来，其中栏位有所谓的关键栏位（Key Field），该栏位具有唯一性，即其值不可重复，且不可为&amp;quot;空值null&amp;quot;。例如：在合并资料时，索引便是扮演欲附加栏位资料之指向性用途的角色。故此索引为不可重复性且不可为空。
数据库事务 事务（transaction）包含一组数据库操作的逻辑工作单元，在事务中包含的数据库操作是不可分割的整体，这些操作要么一起做，要么一起回滚（Roll Back）到执行前的状态。 事务的ACID特性：</description>
    </item>
    
    <item>
      <title>数据结构</title>
      <link>https://bruisesl.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数组 「数组 Array」是一种将 相同类型元素 存储在 连续内存空间 的数据结构，将元素在数组中的位置称为元素的「索引 Index」。
数组名 ：数组的名字
数组元素：就是存放在数组里面的数据
数组索引：就是数组里面连续存储空间的编号，从0开始。而从0开始的原因是根据地址计算公式，索引本质上表示的是内存地址偏移量，首个元素的地址偏移量是 0 ，所以索引值也是 0 。
length ：数组的属性长度，数组名.length拿到数组的长度
数组的声明：数据类型[] 数组名
int[] ages; // 声明一个int类型的数组ages，数组内元素均为int类型 String[] names；// 声明一个String类型的数组names，数组内元素均为String类型 // 也可以用 int ages[]声明，但是不推荐 数组的赋值与取值：
数组在定义后，必须**初始化「赋值」**才能使用。所谓初始化，就是在堆内存中给数组分配存储空间，并为每一 个元素赋上初始值，有两种方式：
动态创建：
**语法 **：数据类型[] 数组名 = new 数据类型[长度] ，长度不能为负数，默认是int类型，最大就是int最大值。
int[] arr1 = new int[3]; // 动态创建了一个int类型的数组arr1，长度3 静态创建：
语法：第一个方式是常用方式，第二个方式作为了解。
数据类型[] 数组名 = {值1, 值2, 值3&amp;hellip;..};
数据类型[] 数组名 = new 数据类型[]{值1,值2,值3&amp;hellip;..};
int[] arr2 = {1,3,5,8,9}; // 静态创建了一个长度为5，int类型的数组arr2，赋值元素 ：1,3,5,8,9 数组赋值</description>
    </item>
    
    <item>
      <title>算法</title>
      <link>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84%E7%AE%97%E6%B3%95/</guid>
      <description>算法 算法定义：
「算法 Algorithm」是在有限时间内解决问题的一组指令或操作步骤。算法具有以下特性：
问题是明确的，需要拥有明确的输入和输出定义。 解具有确定性，即给定相同输入时，输出一定相同。 具有可行性，可在有限步骤、有限时间、有限内存空间下完成。 独立于编程语言，即可用多种语言实现。 数据结构定义：
「数据结构 Data Structure」是在计算机中组织与存储数据的方式。为了提高数据存储和操作性能，数据结构的设计原则有：
空间占用尽可能小，节省计算机内存。 数据操作尽量快，包括数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构的设计是一个充满权衡的过程，这意味着如果获得某方面的优势，则往往需要在另一方面做出妥协。例如，链表相对于数组，数据添加删除操作更加方便，但牺牲了数据的访问速度；图相对于链表，提供了更多的逻辑信息，但需要占用更多的内存空间。
数据结构与算法的关系：
「数据结构」与「算法」是高度相关、紧密嵌合的，体现在：
数据结构是算法的底座。数据结构为算法提供结构化存储的数据，以及操作数据的对应方法。
算法是发挥数据结构优势的舞台。数据结构仅存储数据信息，结合算法才可解决特定问题。
算法有对应最优的数据结构。给定算法，一般可基于不同的数据结构实现，而最终执行效率往往相差很大。
复杂度分析 算法效率评估 算法的设计目标是什么，或者说，如何来评判算法的好与坏。整体上看，我们设计算法时追求两个层面的目标：找到问题解法 与 寻求最优解法。
算法效率则是主要评价维度，包括：
时间效率，即算法的运行速度的快慢。
空间效率，即算法占用的内存空间大小。
注：大多数情况下，时间都是比空间更宝贵的，只要空间复杂度不要太离谱、能接受就行，因此以空间换时间最为常用。
效率评估方法&amp;ndash;实际测试
假设我们现在有算法 A 和 算法 B ，都能够解决同一问题，现在需要对比两个算法之间的效率。最直接的方式，就是找一台计算机，把两个算法都完整跑一遍，并监控记录运行时间和内存占用情况。这种评估方式能够反映真实情况，但是也存在弊端：
难以排除测试环境的干扰因素。硬件配置会影响到算法的性能表现。例如，在某台计算机中，算法 A 比算法 B 运行时间更短；但换到另一台配置不同的计算机中，可能会得到相反的测试结果。这意味着我们需要在各种机器上展开测试，而这是不现实的。
展开完整测试非常耗费资源。随着输入数据量的大小变化，算法会呈现出不同的效率表现。比如，有可能输入数据量较小时，算法 A 运行时间短于算法 B ，而在输入数据量较大时，测试结果截然相反。因此，若想要达到具有说服力的对比结果，那么需要输入各种体量数据，这样的测试需要占用大量计算资源。
效率评估方法&amp;ndash;理论估算
估算方法称为「复杂度分析 Complexity Analysis」或「渐近复杂度分析 Asymptotic Complexity Analysis」。
复杂度分析评估随着输入数据量的增长，算法的运行时间和占用空间的增长趋势。根据时间和空间两方面，复杂度可分为「时间复杂度 Time Complexity」和「空间复杂度 Space Complexity」。 复杂度分析克服了实际测试方法的弊端。一是独立于测试环境，分析结果适用于所有运行平台。二是可以体现不同数据量下的算法效率，尤其是可以反映大数据量下的算法性能。 时间复杂度 统计算法运行时间
运行时间能够直观且准确地体现出算法的效率水平，想要准确预估一段代码的运行时间，需要做：
首先需要 确定运行平台 ，包括硬件配置、编程语言、系统环境等，这些都会影响到代码的运行效率。
评估 各种计算操作的所需运行时间 ，例如加法操作 + 需要 1 ns ，乘法操作 * 需要 10 ns ，打印操作需要 5 ns 等。</description>
    </item>
    
    <item>
      <title>开发软件使用相关</title>
      <link>https://bruisesl.github.io/post/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3/</guid>
      <description>eclipse的使用 介绍：Eclipse 是一个开放源代码的、基于 Java 的可扩展开发平台。eclipse 附带了一个标准的插件集，包括Java 开发工具 Java Developmment Rit, JDk。eclipse 是一个可以提高开发效率的工具。 可自动编译Java文件，简化运行流程。创建 类 管理项目方式更为简单直观。但是现在使用eclipse的企业很少，大多数企业选择使用IDEA进行开发。
区域：左侧工作栏用于创建项目与管理文件，右侧区域用于编写代码，上方选择框最右侧可以选择编写语言。
使用：点击左侧创建项目，创建成功后新建类，输入类的名称并选择类及方法的类型，确认后即可编写。</description>
    </item>
    
    <item>
      <title>问题及解决办法</title>
      <link>https://bruisesl.github.io/post/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</link>
      <pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://bruisesl.github.io/post/%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</guid>
      <description>Mac删除launchpad中无法正常移除的图标 场景：网页中下载dmg安装后，卸载了finder/application内对应程序，但launchpad内仍然存在对应图标，且无法删除。
解决办法：
找到com.apple.dock.launchpad文件夹
打开一个folder，按command+shift+G，在前往当中输入地址/private/var/folders，然后在里边自己尝试找到com.apple.dock.launchpad这个文件夹
找到数据库，获取其路径
打开com.apple.dock.launchpad 文件夹
之后有一个db文件夹，再点进去有一个文件叫db,它就是要找的数据库。
查看db文件简介，复制对应路径，注意从private开始。
开始对数据库进行操作
打开终端，切换盘符至复制路径。
然后输入： sqlite3 db &amp;quot;delete from apps where title=&#39;应用名称&#39;;&amp;quot;&amp;amp;&amp;amp;killall Dock
注意要将应用名称处替换成要删除的图标的名称，然后回车即可。
permission denied (publickey)问题的解决方法 场景：上时间未远端登陆git，导致ssh key过期，git push 失败报错：Permission denied (publickey)
解决办法：重新生成一个新的ssh key ，然后将这个ssh key添加到github账户上面。
检查SSH key是否已经存在 ls ~/.ssh/ 进行检查 id_rsa.pub 是否存在，如果存在，就不用生成一个新的SSH key了，直接跳到下面的第3步。
生成一个新的SSH key 切换盘符至 .ssh 文件
cd /Users/your_user_name/.ssh 输入命令（其中 your_email@example.com 替换成个人邮箱地址）：
ssh-keygen -t rsa -b 2048 -C &amp;#34;your_email@example.com&amp;#34; 回车后输出如下：
Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_name/.</description>
    </item>
    
  </channel>
</rss>
