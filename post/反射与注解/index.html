<!DOCTYPE html>













<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  
  <title>反射与注解 - BruisesL&#39;s blog</title>

  
  
  <meta name="description" content="反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制，反射被视为动态语言的关键。
注：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）
Java反射的原理就是获取Class对象（类在运⾏时叫字节码对象java.lang.Class）然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。
优点：
⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）
缺点：
破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）
反射的使用 字节码对象的获取⽅式：
类名.class
对象名.getClass()
Class.forName(全类名)
public class TestReflect { /** * Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组 */ @Test public void testContructor1() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?&gt; constructor:constructors) { System.out.println(constructor); } } /** * Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有) */ @Test public void testContructor2() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] Constructors = clazz.getDeclaredConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?" />
  <meta name="author" content="BruisesL" />
  

  
  
  
  
  
  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/app.min.css" />

  
  <link rel="preload stylesheet" as="style" href="https://bruisesl.github.io/an-old-hope.min.css" />
  <script
    defer
    src="https://bruisesl.github.io/highlight.min.js"
    onload="hljs.initHighlightingOnLoad();"
  ></script>
  

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/theme.png" />

  
  <link rel="preload" as="image" href="https://bruisesl.github.io/github.svg" />
  

  
  <link rel="icon" href="https://bruisesl.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://bruisesl.github.io/apple-touch-icon.png" />

  
  <meta name="generator" content="Hugo 0.110.0">

  
  

  
  
  
  
  
  
  
  <meta property="og:title" content="反射与注解" />
<meta property="og:description" content="反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制，反射被视为动态语言的关键。
注：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）
Java反射的原理就是获取Class对象（类在运⾏时叫字节码对象java.lang.Class）然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。
优点：
⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）
缺点：
破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）
反射的使用 字节码对象的获取⽅式：
类名.class
对象名.getClass()
Class.forName(全类名)
public class TestReflect { /** * Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组 */ @Test public void testContructor1() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?&gt; constructor:constructors) { System.out.println(constructor); } } /** * Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有) */ @Test public void testContructor2() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] Constructors = clazz.getDeclaredConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bruisesl.github.io/post/%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-02-24T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-24T00:00:00+00:00" />

  
  <meta itemprop="name" content="反射与注解">
<meta itemprop="description" content="反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制，反射被视为动态语言的关键。
注：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）
Java反射的原理就是获取Class对象（类在运⾏时叫字节码对象java.lang.Class）然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。
优点：
⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）
缺点：
破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）
反射的使用 字节码对象的获取⽅式：
类名.class
对象名.getClass()
Class.forName(全类名)
public class TestReflect { /** * Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组 */ @Test public void testContructor1() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?&gt; constructor:constructors) { System.out.println(constructor); } } /** * Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有) */ @Test public void testContructor2() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] Constructors = clazz.getDeclaredConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?"><meta itemprop="datePublished" content="2023-02-24T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-02-24T00:00:00+00:00" />
<meta itemprop="wordCount" content="386">
<meta itemprop="keywords" content="" />
  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="反射与注解"/>
<meta name="twitter:description" content="反射 Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制，反射被视为动态语言的关键。
注：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）
Java反射的原理就是获取Class对象（类在运⾏时叫字节码对象java.lang.Class）然后使用java.lang.reflect里提供的方法操作Class对象，Class与java.lang.reflect构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。
优点：
⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）
缺点：
破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）
反射的使用 字节码对象的获取⽅式：
类名.class
对象名.getClass()
Class.forName(全类名)
public class TestReflect { /** * Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组 */ @Test public void testContructor1() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] constructors = clazz.getConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?&gt; constructor:constructors) { System.out.println(constructor); } } /** * Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有) */ @Test public void testContructor2() throws Exception { //1.获取Student类的Class对象 Class&lt;?&gt; clazz = Class.forName(&#34;reflect.constructor.Student&#34;); //2.获取clazz的所有的公有构造方法 Constructor&lt;?&gt;[] Constructors = clazz.getDeclaredConstructors(); //3.遍历打印所有的构造方法 for (Constructor&lt;?"/>

  
  
</head>


  <body class="not-ready" data-menu="true">
    <header class="header">
  
  <p class="logo">
    <a class="site-name" href="https://bruisesl.github.io">BruisesL&#39;s blog</a><a class="btn-dark"></a>
  </p>
  

  <script>
    let bodyClx = document.body.classList;
    let btnDark = document.querySelector('.btn-dark');
    let sysDark = window.matchMedia('(prefers-color-scheme: dark)');
    let darkVal = localStorage.getItem('dark');

    let setDark = (isDark) => {
      bodyClx[isDark ? 'add' : 'remove']('dark');
      localStorage.setItem('dark', isDark ? 'yes' : 'no');
    };

    setDark(darkVal ? darkVal === 'yes' : sysDark.matches);
    requestAnimationFrame(() => bodyClx.remove('not-ready'));

    btnDark.addEventListener('click', () => setDark(!bodyClx.contains('dark')));
    sysDark.addEventListener('change', (event) => setDark(event.matches));
  </script>

  
  
  <nav class="menu">
    
    <a class="" href="/about/">About</a>
    
  </nav>
  

  
  <nav class="social">
    
    <a
      class="github"
      style="--url: url(./github.svg)"
      href="https://github.com/BruisesL"
      target="_blank"
    ></a>
    
  </nav>
  
</header>


    <main class="main">

<article class="post-single">
  <header class="post-title">
    <aside>
      <time>February 24, 2023</time>
      
      <span>BruisesL</span>
      
    </aside>
    <h1>反射与注解</h1>
  </header>
  <section class="post-content"><h2 id="反射">反射</h2>
<p>Java的反射（reflection）机制是指在程序的<strong>运行状态</strong>中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。<strong>这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制</strong>，反射被视为动态语言的关键。</p>
<p><strong>注</strong>：字节码对象其实就是类加载到java虚拟机中的⼀种状态/另⼀种表现形式（因为jvm不能直接运⾏自己写的类，所以需要转换字节码Class）</p>
<p><img src="/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B.jpg" alt="类加载模型"></p>
<p>Java反射的原理就是获取<code>Class</code>对象（类在运⾏时叫字节码对象<code>java.lang.Class</code>）然后使用<code>java.lang.reflect</code>里提供的方法操作<code>Class</code>对象，<code>Class</code>与<code>java.lang.reflect</code>构成了java的反射技术，反射代码的⼊⼝就是字节码对象，所以如何获取到字节码对象是关键。</p>
<ul>
<li>
<p>优点：</p>
<p>⾮常灵活，功能强⼤（可以获取私有的信息，破坏别⼈代码）</p>
</li>
<li>
<p>缺点：</p>
<p>破坏封装（单例），影响性能（反射的效率要⽐⾮反射操作要低）</p>
</li>
</ul>
<h3 id="反射的使用">反射的使用</h3>
<p><strong>字节码对象的获取⽅式</strong>：</p>
<ol>
<li>
<p><code>类名.class</code></p>
</li>
<li>
<p><code>对象名.getClass()</code></p>
</li>
<li>
<p><code>Class.forName(全类名)</code></p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestReflect</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Constructor&lt;?&gt;[] getConstructors()：返回所有公共构造方法对象的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testContructor1</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取Student类的Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取clazz的所有的公有构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;[]</span> constructors <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getConstructors</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.遍历打印所有的构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor<span style="color:#f92672">:</span>constructors<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>constructor<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有构造方法对象的数组(包括私有)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testContructor2</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取Student类的Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取clazz的所有的公有构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;[]</span> Constructors <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredConstructors</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.遍历打印所有的构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor<span style="color:#f92672">:</span>Constructors<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>			System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>constructor<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：返回单个公共构造方法对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testContructor3</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取公有的无参构造方法   --注意：小括号中,一定要跟构造方法的形参保持一致.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getConstructor</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span><span style="color:#66d9ef">int</span><span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.获取公有的有参构造方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>constructor<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：返回单个构造方法对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testContructor4</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取私有的构造方法   --注意：小括号中,一定要跟构造方法的形参保持一致.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredConstructor</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>反射获取构造⽅法并使⽤</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Constructor&lt;?&gt;[] getConstructors()</code></td>
<td>返回所有公共构造⽅法对象的数组</td>
</tr>
<tr>
<td><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></td>
<td>返回所有构造⽅法对象的数组</td>
</tr>
<tr>
<td><code>Constructor getConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个公共构造⽅法对象</td>
</tr>
<tr>
<td><code>Constructor getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td>
<td>返回单个构造⽅法对象</td>
</tr>
<tr>
<td><code>T newInstance(Object...initargs)</code></td>
<td>根据指定的构造⽅法创建对象</td>
</tr>
<tr>
<td><code>setAccessible(boolean flag)</code></td>
<td>设置为true,表示取消访问检查</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TestReflect2</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  T newInstance(Object...initargs)   | 根据指定的构造方法创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testNewInstance1</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取构造方法对象-公共有参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getConstructor</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.利用newInstance创建Student的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Object o <span style="color:#f92672">=</span> constructor<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>o<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 *  T newInstance(Object...initargs)   | 根据指定的构造方法创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testNewInstance2</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//1.获取Student类的Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取clazz的所有的公有构造方法-空参
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getConstructor</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.利用空参来创建Student的对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Student stu <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Student<span style="color:#f92672">)</span>constructor<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>stu<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//补充：在Class类中,有一个newInstance方法,可以利用空参直接创建一个对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * T newInstance(Object...initargs)   | 根据指定的构造方法创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 * setAccessible(boolean flag)        | 设置为true,表示取消访问检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	 */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">@Test</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">testNewInstance3</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Exception <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//获取一个私有的构造方法并创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">//1.获取Class对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Class<span style="color:#f92672">&lt;?&gt;</span> clazz <span style="color:#f92672">=</span> Class<span style="color:#f92672">.</span><span style="color:#a6e22e">forName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;reflect.constructor.Student&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//2.获取一个私有化的构造方法.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Constructor<span style="color:#f92672">&lt;?&gt;</span> constructor <span style="color:#f92672">=</span> clazz<span style="color:#f92672">.</span><span style="color:#a6e22e">getDeclaredConstructor</span><span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//3.被private修饰的成员,不能直接使用的,如果用反射强行获取并使用,需要临时取消访问检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		constructor<span style="color:#f92672">.</span><span style="color:#a6e22e">setAccessible</span><span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">//4.创建对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		Student stu <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Student<span style="color:#f92672">)</span>constructor<span style="color:#f92672">.</span><span style="color:#a6e22e">newInstance</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Alex&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>		System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>stu<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>反射获取成员变量并使⽤</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Field[] getFields()</code></td>
<td>返回所有公共成员变量对象的数组</td>
</tr>
<tr>
<td><code>Field[] getDeclaredFields()</code></td>
<td>返回所有成员变量对象的数组</td>
</tr>
<tr>
<td><code>Field getField(String name)</code></td>
<td>返回单个公共成员变量对象</td>
</tr>
<tr>
<td><code>Field getDeclaredField(String name)</code></td>
<td>返回单个成员变量对象</td>
</tr>
<tr>
<td><code>void set(Object obj, Object value)</code></td>
<td>给成员变量赋值</td>
</tr>
<tr>
<td><code>Object get(Object obj)</code></td>
<td>给成员变量获取值</td>
</tr>
</tbody>
</table>
<p><strong>反射获取成员方法并使⽤</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Method[] getMethods() </code></td>
<td>返回所有公共成员⽅法对象的数组，包括继承的</td>
</tr>
<tr>
<td><code>Method[] getDeclaredMethods()</code></td>
<td>返回所有成员⽅法对象的数组，不包括继承的</td>
</tr>
<tr>
<td><code>Method getMethod(String name, Class&lt;?&gt;...parameterTypes)  </code></td>
<td>返回单个公共成员⽅法对象</td>
</tr>
<tr>
<td><code>Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)  </code></td>
<td>返回单个成员⽅法对象</td>
</tr>
<tr>
<td><code>Object invoke(Object obj, Object... args) </code></td>
<td>运⾏⽅法</td>
</tr>
</tbody>
</table>
<h2 id="注解">注解</h2>
<p>注解（Annotation），也叫元数据，标签，注释。 它是JDK1.5及以后版本引⼊的⼀个特性，与类、接⼝、枚举是在同⼀个层次。</p>
<p>可以声明在包、类、字段、⽅法、局部变量、⽅法参数等的前⾯，⽤来对这些元素进⾏说明，注释。</p>
<ul>
<li>
<p>注解与注释的区别</p>
<p>注释：//，/**/    写给程序员看的；</p>
<p>注解：@Override    写给程序看的；</p>
</li>
<li>
<p>注解的作用：</p>
<ol>
<li>
<p>编写⽂档：事实上，在Java中我们可以通过注解去⽣成API⽂档，例如我们常⻅的参数值 <code>@parameter</code>，返回值<code>@return</code>等，只有标识了这些，才能通过API⽂档更快速和有条理的查看到对应的相关信息。</p>
</li>
<li>
<p>分析代码：（单独使⽤）是<strong>主要作⽤</strong>，通过代码⾥标识的注解对代码进⾏分析<strong>使⽤反射</strong></p>
</li>
</ol>
<p>（⽐如 <code>@Data</code>、<code>@Service</code>、 <code>@Controller</code>等）极⼤的提⾼开发效率</p>
<ol start="3">
<li>编译检查：通过代码⾥标识的注解让编译器能够实现基本的编译检查，⽐如<code>@Override</code>、 <code>@SuppressWarnings</code></li>
</ol>
</li>
</ul>
<h3 id="注解的语法">注解的语法</h3>
<p>@ + 注解的名称 &ndash; ⽐如<code>@Override</code>，<code>@SuppressWarnings</code>等；</p>
<p><code>@Override</code>：编译检查，⽤来检查标记的⽅法是否复写了⽗类的⽅法</p>
<ol>
<li>只能⽤在⽅法上，写在其他上⾯会报错（编译器报错）；</li>
<li>可以不写，但是不进⾏检查，如果是复写的⽅法，写错了也不报错；</li>
<li>写上注解之后，复写⽅法⽅法名字和参数列表就必须和⽗类的⽅法⼀致，如果写错，编译器会</li>
</ol>
<p>帮你检查，会报错；</p>
<p><code>@SuppressWarnings</code>：抑制/增压警告</p>
<ol>
<li>可以写在代码中，写在⽅法上，写在类上⾯，三者作⽤域不⼀样；</li>
<li>可以不写，但是代码/包/⼯程上会出现⻩⾊警告</li>
<li>写上之后，代码/包/⼯程上不会出现⻩⾊警告</li>
</ol>
<p><code>@Deprecated</code>：标志当前⽅法或者类已经过时</p>
<ol>
<li>可以使⽤在类中，⽅法中，⽤在⽅法中居多；</li>
<li>过时的⽅法有可能在⽤，所以不能删除，不能注释掉。只是建议以后不要使⽤；</li>
<li>Java中也有已经过时的⽅法(Date对象的<code>toLocaleString()</code>⽅法)</li>
</ol>
<p><code>@SafeVarargs</code>：抑制堆污染</p>
<p>堆污染：当使⽤带泛型和可变参数的⽅法时，就会出现编译警告，可以使⽤<code>@SafeVarargs</code>抑制该</p>
<p>警告。<code>@SafeVarargs</code>是jdk1.7才出现的，之前使⽤<code>@SuppressWarings</code>解决</p>
<h3 id="元注解">元注解</h3>
<p>注解上⾯的注解，写在注解上⾯的，对注解进⾏说明的。 元注解在注解上才有作⽤，如果⾃定义注解，需要了解元注解；</p>
<p><strong>分类</strong>：</p>
<p><code>@Target</code>：指定该注解的使⽤范围，没有指定什么地⽅都可以⽤；</p>
<ol>
<li>
<p>CONSTRUCTOR:⽤于描述构造器</p>
</li>
<li>
<p>FIELD:⽤于描述字段</p>
</li>
<li>
<p>LOCAL_VARIABLE:⽤于描述局部变量</p>
</li>
<li>
<p>METHOD:⽤于描述⽅法</p>
</li>
<li>
<p>PACKAGE:⽤于描述包</p>
</li>
<li>
<p>PARAMETER:⽤于描述参数</p>
</li>
<li>
<p>TYPE:⽤于描述类、接⼝(包括注解类型) 或enum声明</p>
</li>
</ol>
<p><code>@Retention</code>：指定⾃定义注解在代码中⽣效的⽣命周期；</p>
<ol>
<li>
<p>SOURCE:源码阶段，⼀旦编译成字节码⽂件就不存在了， 在字节码⽂件中该注解是不存在的 。</p>
</li>
<li>
<p>Class：字节码阶段，⼀旦加载到JVM就不存在了。</p>
</li>
<li>
<p>Runtime：运⾏时，在JVM执⾏时还存在。</p>
</li>
</ol>
<p><code>@Documented</code>：指定⾃定义注解在⽣成⽂档时，是否显示。</p>
<ol>
<li>如果某个注解使⽤了<code>@Deprecated</code>元注解，那么这个注解会显示在⽂档中，否则不出现； 相反<code>@Override</code>注解上没有<code>@Documented</code>⽂档，那么所有使⽤<code>@Override</code>注解的⽅法上，在⽣成 ⽂档时，都看不⻅<code>@Override</code>注解 。</li>
</ol>
<p><code>@Inherited</code>：指定⾃定义注解是否被继承</p>
<ol>
<li>例如⾃定义注解上有元注解<code>@Inherited</code> 假设⼀个注解在定义时，使⽤了<code>@Inherited</code>，然后该注解在⼀个类上使⽤，如果这个类有⼦类， 那么通过反射我们可以从类的⼦类上获取到同样的注解。</li>
</ol>
<h3 id="注解的三要素">注解的三要素</h3>
<p><strong>第⼀要素</strong>：⾸先需要⼀个注解（其他⼈写的注解 or ⾃定义的注解）。写好的注解：不需要⾃⼰去实现，别⼈已经写好了功能，直接使⽤就是；⾃定义注解：需要⾃⼰写代码去实现功能；</p>
<p><strong>第⼆要素</strong>：使⽤方式，可以在哪些地方使用</p>
<p>第三要素：功能实现</p>
</section>

  
  

  
  
  
  <nav class="post-nav">
    
    <a class="prev" href="https://bruisesl.github.io/post/javabean/"><span>←</span><span>JavaBean</span></a>
     
    <a class="next" href="https://bruisesl.github.io/post/%E5%BE%85%E5%AE%8C%E5%96%84java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span>Java设计模式</span><span>→</span></a>
    
  </nav>
  

  
  
</article>

</main>

    <footer class="footer">
  <p>&copy; 2023 <a href="https://bruisesl.github.io">BruisesL&#39;s blog</a></p>
  <p>Powered by <a href="https://gohugo.io/" rel="noopener" target="_blank">Hugo️️</a>️</p>
  <p>
    <a href="https://github.com/nanxiaobei/hugo-paper" rel="noopener" target="_blank">Paper 5.0</a>
  </p>
</footer>

  </body>
</html>
